<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[EFE Tech]]></title>
  <subtitle><![CDATA[百度EFE（Excellent FrontEnd）技术体系]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://efe.baidu.com/"/>
  <updated>2015-05-26T06:46:00.000Z</updated>
  <id>http://efe.baidu.com/</id>
  
  <author>
    <name><![CDATA[efe]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[CSS硬件加速的好与坏]]></title>
    <link href="http://efe.baidu.com/blog/hardware-accelerated-css-the-nice-vs-the-naughty/"/>
    <id>http://efe.baidu.com/blog/hardware-accelerated-css-the-nice-vs-the-naughty/</id>
    <published>2015-05-25T16:00:00.000Z</published>
    <updated>2015-05-26T06:46:00.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自Ariya Hidayat的<a href="http://calendar.perfplanet.com/2014/hardware-accelerated-css-the-nice-vs-the-naughty/" target="_blank" rel="external">Hardware Accelerated CSS: The Nice vs The Naughty</a>。感谢<a href="https://github.com/599316527" target="_blank" rel="external">Kyle He</a>帮助校对。</p>
</blockquote>
<p>每个人都痴迷于<a href="http://paulbakaus.com/tutorials/performance/the-illusion-of-motion/" target="_blank" rel="external">60桢每秒</a>的顺滑动画。为了实现这个顺滑体验现在用的最流行的一个做法就是使用『<a href="http://www.smashingmagazine.com/2012/06/21/play-with-hardware-accelerated-css/" target="_blank" rel="external">CSS硬件加速</a>』。在一些极端例子中，强制使用translate3d意味着大大提高应用程序的性能。</p>
<p>现代浏览器大都可以利用GPU来加速<a href="http://blogs.msdn.com/b/ie/archive/2010/09/10/the-architecture-of-full-hardware-acceleration-of-all-web-page-content.aspx" target="_blank" rel="external">页面渲染</a>。在GPU的众多特性之中，它可以存储一定数量的纹理（一个矩形的像素点集合）并且高效地操作这些纹理（比如进行特定的移动、缩放和旋转操作）。这些特性在实现一个<a href="http://ariya.ofilabs.com/2013/06/optimizing-css3-for-gpu-compositing.html" target="_blank" rel="external">流畅的动画</a>时特别有用。浏览器不会在动画的每一帧都绘制一次，而是生成DOM元素的快照，并作为GPU纹理（也被叫做层）存储起来。之后浏览器只需要告诉GPU去转换指定的纹理来实现DOM元素的动画效果。这就叫做<strong>GPU合成</strong>，也经常被称作『硬件加速』。</p>
<p>不幸的是，浏览器是一个很<a href="http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" target="_blank" rel="external">复杂</a>的软件（Firefox有<a href="https://www.openhub.net/p/firefox/analyses/latest/languages_summary" target="_blank" rel="external">几百万行代码</a>）。因此一句简单的『使用translate3d来提高性能』并不能囊括所有的情况。如果碰巧有效那不过是瞎猫碰上死耗子而已。所以有必要知道更多的运行机制，才能更好地处理实际情况。</p>
<a id="more"></a>
<p>想象使用GPU加速的动画就像是Vin Diesel（速度与激情的主角）开着Dominic标志性的汽车 —— Dodge Charger。它的定制900 hp引擎可以让它在一瞬间从0加速到60码。但是如果你开着它在拥挤的高速公路上又有什么用呢？这种情况下你选择的车辆Charger是正确的。但是问题是你还在一个拥堵的高速公路上。</p>
<p>GPU合成也是同样的道理。许多动画还是需要CPU的介入，这毕竟是浏览器工作的方式，你无法改变它。而连接CPU和GPU的总线的带宽不是无限的，所以需要关注数据在CPU和GPU之间的传输，要尽量避免造成通道的拥挤。换句话说你需要一直注意<strong>像素的传输</strong>。</p>
<div class="figure">
<img src="/blog/hardware-accelerated-css-the-nice-vs-the-naughty/1.png">
</div>
<p>首先也是最重要的任务就是了解创建的<strong>合成层的数量</strong>。因为每一个层都对应了一个GPU纹理，所以有太多的层会消耗很多内存。这可能导致出现预期之外的行为，可能会导致潜在的崩溃。幸运的是你很容易就能通过浏览器来检查页面上的合成层数量。</p>
<ul>
<li>对于Firefox，打开<code>about:config</code>然后设置<code>layers.draw-borders</code>为true。</li>
<li>如果是Chrome用户，打开<code>chrome://flags/#composited-layer-borders</code>启用，然后打开开发工具勾选<code>Show composited layer borders</code>。</li>
<li>对于Safari用户，先打开终端运行<code>defaults write com.apple.Safari IncludeInternalDebugMenu 1</code>。然后重新启动下Safari，菜单中找到一个开发菜单打开Web检查器就能在右边看到一个tab叫『层』了。选中之后你就可以在Web检查器的<a href="https://developer.apple.com/library/safari/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/ResourcesandtheDOM/ResourcesandtheDOM.html#//apple_ref/doc/uid/TP40007874-CH3-SW8" target="_blank" rel="external">边栏</a>中看到每个层的内存消耗。</li>
</ul>
<p>当这些浏览器都正确的配置之后，每个DOM元素的合成层都会被标记一个额外的边框（你可以通过这个<a href="http://ariya.github.io/css/spinningcube/" target="_blank" rel="external">Spinning Cube</a> Demo来测试下）。用这种方法就可以验证你的页面是否有太多的层。</p>
<p>另一个重点就是保持GPU和CPU之间的传输量达到最小值。换句话说，层的更新数量最好是一个理想的常量。每次合成层更新，一堆新的像素就可能需要传输给GPU。因此为了高性能，在动画开始之后避免层的更新也是很重要的（避免动画进行中时有其他层一直更新导致拥堵）。这可以通过选择<a href="http://www.html5rocks.com/en/tutorials/speed/high-performance-animations/" target="_blank" rel="external">恰当的CSS属性</a>实现动画来解决：<a href="http://dev.w3.org/csswg/css-transforms/" target="_blank" rel="external">transformation</a>（translate, scale, rotate）、<a href="http://dev.w3.org/csswg/css-color/#transparency" target="_blank" rel="external">opacity</a>或者<a href="http://dev.w3.org/fxtf/filters/" target="_blank" rel="external">filters</a>。</p>
<p>如果你在使用Safari的web检查器，选择『层』标签后就能在侧栏看到『绘图』区域。这里的数字代表了Safari提交当前层的新纹理次数。在<a href="http://codepen.io/ariya/full/xuwgy" target="_blank" rel="external">Colorful Boxes</a>这个demo上试一试。这个demo中每个box都会不停地修改自己的背景颜色。不幸地是修改box的背景色会强制合成层更新纹理，因此它的『绘图』数量会不停的变大。如果只有一个盒子，那还没什么关系，如果是几百个盒子那就很容易达到GPU的瓶颈。当然这是一个极端的例子，只是提醒下你在这种情况下<code>translate3d</code>也救不了你。</p>
<p>需求是创造之源。合成层的限制也会引导我们创造更多令人惊讶的方法来利用浏览器的硬件加速特性。比如我们可以将UI的初始状态和结束状态放在同一个合成层中，然后通过<a href="https://www.youtube.com/watch?v=RCFQu0hK6bU" target="_blank" rel="external">剪切</a>的方法来显示一部分并隐藏另一部分。还有一个类似的方法是通过<a href="http://ariya.ofilabs.com/2014/02/tricks-for-gpu-composited-css.html" target="_blank" rel="external">两层叠加</a>造成视觉错觉来实现一些特别的效果。通过修改两个层的透明度来实现动画效果，比如这个<a href="http://codepen.io/ariya/full/nFADe" target="_blank" rel="external">Glowing Effect</a> demo。</p>
<p>另外一个常用的方法就是维护一个合成层池，这样也可以减少像素的传输。当有些层不需要的时候，它们不会被销毁。它们会被移到屏幕之外或者设置为透明的。在一些情况下，UI设计时可以规定一个固定的合成层数量。比如下面这个<a href="http://ariya.github.io/kinetic/5/index.html" target="_blank" rel="external">Cover Flow</a>的例子，同时只能显示9张图片。即使它需要可以显示成千上万的书本封面（在左右滑动时），你也不需要一次性构建这么多合成层。只需要一个小小的修改，那就是在滑动时将旧图片的层移出作为新图片的层使用。用户根本不会感觉到变化。</p>
<div class="figure">
<img src="/blog/hardware-accelerated-css-the-nice-vs-the-naughty/2.png">
</div>
<p>同样不要忘记你必须使用性能检测工具（profiler）来检查你的理论是否成立。性能优化是非常严肃的话题，如果只是依靠自己的直觉那就很容易出错。Chrome的用户应该启用<code>chrome://flags/#show-fps-counter</code>。同样Firefox也要在<code>about:config</code>里面启用<code>layers.acceleration.draw-fps</code>。通过帧率来检测你的动画。如果帧率下降到60fps（或者没达到你要的效果），那么就该调查下原因。Chrome的<a href="https://developer.chrome.com/devtools/docs/timeline#frames-mode" target="_blank" rel="external">Timeline特性</a>或者Safari的<a href="https://developer.apple.com/library/safari/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/Instruments/Instruments.html#//apple_ref/doc/uid/TP40007874-CH4-SW4" target="_blank" rel="external">Timeline面板</a>都可以让你了解渲染过程中的细节：layout、painting和合成。</p>
<p>为了做好性能的回归测试，自动实现如上操作是很有必要的。这时<a href="http://nparashuram.com/" target="_blank" rel="external">Parashuram</a>的<a href="https://github.com/axemclion/browser-perf" target="_blank" rel="external">browser-perf</a>就会变得非常有用。几星期前他已经写过一些<a href="http://calendar.perfplanet.com/2014/automating-web-page-rendering-performance/" target="_blank" rel="external">博文</a>来介绍自动化测试网页性能。对于本文的情况，<a href="http://blog.nparashuram.com/2014/06/gpu-composited-css-and-browser-perf.html" target="_blank" rel="external">测量层数和层更新次数</a>是非常有用的。有了这些数据你就可以在数值超过限制的时候告警。</p>
<p>已经有许多文章讲述过CSS硬件加速这个课题了，希望这篇文章能成为另一个快速帮助手册，教你如何正确地使用GPU合成来加速你的CSS动画。远离麻烦丝般顺滑！</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文翻译自Ariya Hidayat的<a href="http://calendar.perfplanet.com/2014/hardware-accelerated-css-the-nice-vs-the-naughty/">Hardware Accelerated CSS: The Nice vs The Naughty</a>。感谢<a href="https://github.com/599316527">Kyle He</a>帮助校对。</p>
</blockquote>
<p>每个人都痴迷于<a href="http://paulbakaus.com/tutorials/performance/the-illusion-of-motion/">60桢每秒</a>的顺滑动画。为了实现这个顺滑体验现在用的最流行的一个做法就是使用『<a href="http://www.smashingmagazine.com/2012/06/21/play-with-hardware-accelerated-css/">CSS硬件加速</a>』。在一些极端例子中，强制使用translate3d意味着大大提高应用程序的性能。</p>
<p>现代浏览器大都可以利用GPU来加速<a href="http://blogs.msdn.com/b/ie/archive/2010/09/10/the-architecture-of-full-hardware-acceleration-of-all-web-page-content.aspx">页面渲染</a>。在GPU的众多特性之中，它可以存储一定数量的纹理（一个矩形的像素点集合）并且高效地操作这些纹理（比如进行特定的移动、缩放和旋转操作）。这些特性在实现一个<a href="http://ariya.ofilabs.com/2013/06/optimizing-css3-for-gpu-compositing.html">流畅的动画</a>时特别有用。浏览器不会在动画的每一帧都绘制一次，而是生成DOM元素的快照，并作为GPU纹理（也被叫做层）存储起来。之后浏览器只需要告诉GPU去转换指定的纹理来实现DOM元素的动画效果。这就叫做<strong>GPU合成</strong>，也经常被称作『硬件加速』。</p>
<p>不幸的是，浏览器是一个很<a href="http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/">复杂</a>的软件（Firefox有<a href="https://www.openhub.net/p/firefox/analyses/latest/languages_summary">几百万行代码</a>）。因此一句简单的『使用translate3d来提高性能』并不能囊括所有的情况。如果碰巧有效那不过是瞎猫碰上死耗子而已。所以有必要知道更多的运行机制，才能更好地处理实际情况。</p>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://efe.baidu.com/tags/CSS/"/>
    
      <category term="Hardware Accelerated" scheme="http://efe.baidu.com/tags/Hardware-Accelerated/"/>
    
      <category term="硬件加速" scheme="http://efe.baidu.com/tags/%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用ES6进行开发的思考]]></title>
    <link href="http://efe.baidu.com/blog/es6-develop-overview/"/>
    <id>http://efe.baidu.com/blog/es6-develop-overview/</id>
    <published>2015-05-20T16:00:00.000Z</published>
    <updated>2015-05-21T01:39:14.000Z</updated>
    <content type="html"><![CDATA[<p>ECMAScript6已经于近日进入了RC阶段，而早在其处于社区讨论时，我就开始一直在尝试使用ES6进行开发的方案。在<a href="https://babeljs.io" target="_blank" rel="external">Babel</a>推出后，基于ES6的开发也有了具体可执行的解决方案，无论是Build还是Debug都能得到很好的支持。</p>
<p>而在有了充足的环境、工具之后，我们面临的是对ES6众多新特性的选择和分析，以便选取一个最佳的子集，让我们可以享受ES6带来的便利（减少代码量、提高可读性等）的同时，也可以顺利运行于当前以ES3-ES5为主的浏览器环境中。</p>
<p>经过分析后，本文试图对ES6各个特性得出是否适合应用的初步结论，并一一解释其使用场景。ES6的特性列表选自<a href="https://github.com/lukehoban/es6features" target="_blank" rel="external">es6features</a>。</p>
<ul>
<li>★★★ 推荐使用</li>
<li>★★ 有考虑地使用</li>
<li>★ 慎重地使用</li>
<li>☆ 不使用</li>
</ul>
<table>
<thead>
<tr class="header">
<th align="left">特性</th>
<th align="center">推荐程度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">arrows</td>
<td align="center">★★★</td>
</tr>
<tr class="even">
<td align="left">classes</td>
<td align="center">★★★</td>
</tr>
<tr class="odd">
<td align="left">enhanced object literals</td>
<td align="center">★★★</td>
</tr>
<tr class="even">
<td align="left">template strings</td>
<td align="center">★★★</td>
</tr>
<tr class="odd">
<td align="left">destructuring</td>
<td align="center">★★</td>
</tr>
<tr class="even">
<td align="left">default + rest + spread</td>
<td align="center">★★★</td>
</tr>
<tr class="odd">
<td align="left">let + const</td>
<td align="center">★★★</td>
</tr>
<tr class="even">
<td align="left">iterators + for..of</td>
<td align="center">★★</td>
</tr>
<tr class="odd">
<td align="left">generators</td>
<td align="center">★</td>
</tr>
<tr class="even">
<td align="left">unicode</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">modules</td>
<td align="center">★★</td>
</tr>
<tr class="even">
<td align="left">module loaders</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">map + set + weakmap + weakset</td>
<td align="center">★★</td>
</tr>
<tr class="even">
<td align="left">proxies</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">symbols</td>
<td align="center">★</td>
</tr>
<tr class="even">
<td align="left">subclassable built-ins</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">promises</td>
<td align="center">★★★</td>
</tr>
<tr class="even">
<td align="left">math + number + string + array + object APIs</td>
<td align="center">★★★</td>
</tr>
<tr class="odd">
<td align="left">binary and octal literals</td>
<td align="center">★</td>
</tr>
<tr class="even">
<td align="left">reflect api</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">tail calls</td>
<td align="center">★★</td>
</tr>
</tbody>
</table>
<p>接下来我们以上特性挨个进行介绍。需要关注一点：如果你不想使用shim库（如Babel的<code>browser-polyfill.js</code>和<code>generatorsRuntime.js</code>）或者想使用尽可能少的helper（Babel的<code>externalHelpers</code>配置），那么需要按你的需求进一步缩减可使用的ES6特性，如<code>Map</code>、<code>Set</code>这些就不应该使用。</p>
<a id="more"></a>
<h2 id="语法增强类">语法增强类</h2>
<h3 id="arrow-function">Arrow function</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external">Arrow functions</a>是ES6在语法上提供的一个很好的特性，其特点有：</p>
<ul>
<li>语法更为简洁了。</li>
<li>文法上的固定<code>this</code>对象。</li>
</ul>
<p>我们<strong>鼓励在可用的场景下使用Arrow functions</strong>，并以此代替原有的<code>function</code>关键字。</p>
<p>当然Arrow functions并不是全能的，在一些特别的场景下并不十分适用，最为典型的是Arrow functions无法提供函数名称，因此做递归并不方便。虽然可以使用<a href="http://en.wikipedia.org/wiki/Y_combinator" target="_blank" rel="external">Y combinator</a>来实现函数式的递归，但其可读性会有比较大的损失。</p>
<p>配合后文会提到的对象字面量增强，现在我们定义方法/函数会有多种方式，建议执行以下规范：</p>
<ul>
<li><p>所有的Arrow functions的参数均使用括号<code>()</code>包裹，即便只有一个参数：</p>
<pre><code>// Good
let foo = (x) =&gt; x + 1;

// Bad
let foo = x =&gt; x + 1;</code></pre></li>
<li><p>定义函数尽量使用Arrow functions，而不是<code>function</code>关键字：</p>
<pre><code>// Good
let foo = () =&gt; {
    // code
};

// Bad
function foo() {
    // code
}

// Bad
let foo = function () {
    // code
}</code></pre>
<p>除非当前场景不合适使用Arrow functions，如函数表达式需要自递归、需要运行时可变的<code>this</code>对象等。</p></li>
<li><p>对于对象、类中的方法，使用增强的对象字面量：</p>
<pre><code>// Good
let foo = {
    bar() {
        // code
    }
};

// Bad
let foo = {
    bar: () =&gt; {
        // code
    }
};

// Bad
let foo = {
    bar: function () {
        // code
    }
};</code></pre></li>
</ul>
<h3 id="增强的对象字面量">增强的对象字面量</h3>
<p>对象字面量的增强主要体现在3个方面：</p>
<h4 id="可在对象中直接定义方法">可在对象中直接定义方法</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    bar() &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们<strong>推荐使用</strong>这种方式定义方法。</p>
<h4 id="可使用通过计算得出的键值">可使用通过计算得出的键值</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> MY_KEY = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    [MY_KEY + <span class="string">'Hash'</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们<strong>推荐在需要的时候使用计算得出的键值</strong>，以便在一个语句中完成整个对象的声明。</p>
<h4 id="与当前scope中同名变量的简写">与当前Scope中同名变量的简写</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    bar <span class="comment">// 相当于bar: bar</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们<strong>并不推荐</strong>这样的用法，这对可读性并没有什么帮助。</p>
<h3 id="模板字符串">模板字符串</h3>
<p>模板字符串的主要作用有2个：</p>
<h3 id="多行字符串">多行字符串</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html =</span><br><span class="line">`&lt;div&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span>`</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看出，实际使用多行字符串时，对齐是个比较麻烦的事。如果<code>let html</code>这一行本身又有缩进，那么会让代码更为难受一些。</p>
<p>因此我们<strong>不推荐使用多行字符串</strong>，必要时还是可以使用数组和<code>join('')</code>配合，而生成HTML的场景我们应该尽量使用模板引擎。</p>
<h4 id="字符串变量替换">字符串变量替换</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = `Hello $&#123;name&#125;, it<span class="string">'s $&#123;time&#125; now`;</span></span><br></pre></td></tr></table></figure>
<p>这是一个非常方便的功能，我们<strong>鼓励使用</strong>。但需要注意这些变量并不会被HTML转义，所以在需要HTML转义的场景，还是乖乖使用模板引擎或者其它的模板函数。</p>
<h3 id="解构">解构</h3>
<p>解构（原谅我没什么好的翻译）是个比较复杂的语法，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, bar] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;id, name, children&#125; = getTreeRoot();</span><br></pre></td></tr></table></figure>
<p>还可以有更复杂的，具体可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="external">MDN的文档</a>。</p>
<p>对于这样一个复杂且多变的语法，我们要有选择地使用，建议遵循以下原则：</p>
<ul>
<li>不要一次通过解构定义过多的变量，建议不要超过5个。</li>
<li>谨慎在解构中使用“剩余”功能，即<code>let [foo, bar, ...rest] = getValue()</code>这种方式。</li>
<li>不要在对象解构中使用过深层级，建议不要超过2层。</li>
</ul>
<h3 id="函数参数增强">函数参数增强</h3>
<p>ES6为函数参数提供了默认值、剩余参数等功能，同时在调用函数时允许将数组展开为参数，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (x = <span class="number">1</span>) =&gt; x + <span class="number">1</span>;</span><br><span class="line">foo(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> extend = (source, ...args) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> target <span class="keyword">in</span> args) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> <span class="built_in">Object</span>.keys(target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!source.hasOwnProperty(name) &#123;</span><br><span class="line">                source[name] = target[name];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> extensions = [</span><br><span class="line">    &#123;name: <span class="string">'Zhang'</span>&#125;,</span><br><span class="line">    &#123;age: <span class="number">17</span>&#125;,</span><br><span class="line">    &#123;work: <span class="string">'hard'</span>&#125;</span><br><span class="line">];</span><br><span class="line">extend(&#123;&#125;, ...extensions);</span><br></pre></td></tr></table></figure>
<p>我们<strong>鼓励使用这些特性让函数的声明和调用变得更为简洁</strong>，但有一些细节需要注意：</p>
<ul>
<li>在使用默认参数时，如果参数默认值是固定且不会修改的，建议使用一个常量来作为默认值，避免每一次生成的开销。</li>
<li>不要对<code>arguments</code>对象使用展开运算，这不是一个数组。</li>
</ul>
<h2 id="关键字类">关键字类</h2>
<h3 id="let和const">let和const</h3>
<p>这是2个用来定义变量的关键字，众所周知的，<code>let</code>表示块作用域的变量，而<code>const</code>表示常量。</p>
<p>需要注意的是，<code>const</code>仅表示这个变量不能被再将赋值，但并不表示变量是对象、数组时其内容不能改变。如果需要一个不能改变内容的对象、数组，使用<code>Object.freeze</code>方法定义一个真正的常量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DEFAULT_OPTIONS = <span class="built_in">Object</span>.freeze(&#123;id: <span class="number">0</span>, name: <span class="string">'unknown'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>不过如果你在程序中能控制不修改对象的话，这并不具备什么意义，<code>Object.freeze</code>是否会引起执行引擎的进一步优化也尚未得到证实。</p>
<p>我们<strong>推荐使用<code>let</code>全面替代<code>var</code></strong>。同时<strong>建议仅在逻辑上是常量的情况下使用<code>const</code></strong>，不要任何不会被二次赋值的场景均使用<code>const</code>。</p>
<h3 id="迭代器和for..of">迭代器和for..of</h3>
<p>迭代器是个好东西，至少我们可以很简单地遍历数组了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> array) &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是迭代器本身存在一些细微的缺点：</p>
<ul>
<li>性能稍微差了一些，对于数组来说大致与<code>Array.prototype.forEach</code>相当，比不过原生的<code>for</code>循环。</li>
<li>不能在循环体中得到索引<code>i</code>的值，因此如果需要索引则只能用原生的<code>for</code>循环。</li>
<li>判断一个对象是否可迭代比较烦人，没有原生方法提供，需要自行使用<code>typeof o[Symbol.iterator] === 'function'</code>判断。</li>
</ul>
<p>对于迭代器，我们<strong>鼓励使用并代替原生<code>for</code>循环</strong>，且推荐关注以下原则：</p>
<ul>
<li>对于仅一个语句的循环操作，建议使用<code>forEach</code>方法，配合Arrow functions可非常简单地在一行写下循环逻辑。</li>
<li>对于多个语句的循环操作，建议使用<code>for..of</code>循环。</li>
<li>对于循环的场景，需要注意非数组但可迭代的对象，如<code>Map</code>和<code>Set</code>等，因此除<code>arguments</code>这类对象外，均建议直接判断是否可迭代，而不是<code>length</code>属性。</li>
</ul>
<h3 id="生成器">生成器</h3>
<p>生成器（Generators）也是一个比较复杂的功能，具体可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="external">MDN的文档</a>。</p>
<p>对于生成器，我的建议是<strong>非常谨慎地使用</strong>，理由如下：</p>
<ul>
<li>生成器不是用来写异步的，虽然他确实有这样一个效果，但这仅仅是一种Hack。异步在未来一定是属于<code>async</code>和<code>await</code>这两个关键字的，但太多人眼里生成器就是写异步用的，这会导致滥用。</li>
<li>生成器经过Babel转换后生成的代码较多，同时还需要<code>generatorsRuntime</code>库的支持，成本较高。</li>
<li>我们实际写应用的大部分场景下暂时用不到。</li>
</ul>
<p>生成器最典型的应用可以参考<a href="https://msdn.microsoft.com/en-us/library/bb397926.aspx" target="_blank" rel="external">C#的LINQ</a>获取一些经验，将对一个数组的多次操作合并为一个循环是其最大的贡献。</p>
<h3 id="模块和模块加载器">模块和模块加载器</h3>
<p>ES6终于在语言层面上定义了模块的语法，但这并不代表我们现在可以使用ES6的模块，因为实际在ES6定稿的时候，它把模块加载器的规范给移除了。因此我们现在有的仅仅是一个模块的<code>import</code>和<code>export</code>语法，但具体如“模块名如何对应到URL”、“如何异步/同步加载模块”、“如何按需加载模块”等这些均没有明确的定义。</p>
<p>因此，在模块这一块，我们的建议是<strong>使用标准语法书写模块，但使用AMD作为运行时模块解决方案</strong>，其特点有：</p>
<ul>
<li>保持使用<code>import</code>和<code>export</code>进行模块的引入和定义，可以安全地使用命名<code>export</code>和默认<code>export</code>。</li>
<li>在使用Babel转换时，配置<code>modules: 'amd'</code>转换为AMD的模块定义。</li>
<li>假定模块的URL解析是AMD的标准，<code>import</code>对应的模块名均以AMD标准书写。</li>
<li>不要依赖<code>SystemJS</code>这样的ES6模块加载器。</li>
</ul>
<p>这虽然很可能导致真正模块加载器规范定型后，我们的<code>import</code>模块路径是不规范的。但出于ES6的模块不配合HTTP/2简直没法完的考虑，AMD一定很长一段时间内持续存在，我们的应用基本上都是等不到HTTP/2实际可用的日子的，所以无需担心。</p>
<h2 id="类型增强类">类型增强类</h2>
<h3 id="unicode支持">Unicode支持</h3>
<p>这个东西基本没什么影响，我们很少遇到这些情况且已经习惯了这些情况，所以可以认为这个特性不存在而继续开发。</p>
<h3 id="map和set">Map和Set</h3>
<p>两个非常有用的类型，但对不少开发者来说，会困惑于其跟普通对象的区别，毕竟我们已经拿普通对象当<code>Map</code>和<code>Set</code>玩了这么多年了，也很少自己写一个类型出来。</p>
<p>对于此，我们的建议是：</p>
<ul>
<li>当你的元素或者键值有可能不是字符串时，无条件地使用<code>Map</code>和<code>Set</code>。</li>
<li>有移除操作的需求时，使用<code>Map</code>和<code>Set</code>。</li>
<li>当仅需要一个不可重复的集合时，使用<code>Set</code>优先于普通对象，而不要使用<code>{foo: true}</code>这样的对象。</li>
<li>当需要遍历功能时，使用<code>Map</code>和<code>Set</code>，因为其可以简单地使用<code>for..of</code>进行遍历。</li>
</ul>
<p>因此，事实上仅有一种情况我们会使用普通的对象，即使用普通对象来表达一个仅有增量<code>Map</code>，且这个<code>Map</code>的键值是字符串。</p>
<p>另外，<code>WeakMap</code>和<code>WeakSet</code>是没有办法模拟实现的，因此<strong>不要使用</strong>。</p>
<h3 id="proxy">Proxy</h3>
<p>这不是一个可以模拟实现的功能，没法用，因此<strong>不要使用Proxy</strong>。</p>
<h3 id="symbol">Symbol</h3>
<p><code>Symbol</code>最简单的解释是“可用于键值的对象”，最大的用处可能就是用来定义一些私有属性了。</p>
<p>我们建议<strong>谨慎使用<code>Symbol</code></strong>，如果你使用它来定义私有属性，那么请保持整个项目内是一致的，不要混用<code>Symbol</code>和闭包定义私有属性等手段。</p>
<h3 id="可继承的内置类型">可继承的内置类型</h3>
<p>按照ES6的规范，内置类型如<code>Array</code>、<code>Function</code>、<code>Date</code>等都是可以继承且没有什么坑的。但是我们的代码要跑在ES3-5的环境下，显然这一特性是不能享受的。</p>
<h3 id="promise">Promise</h3>
<p>这个真没什么好说的，即便不是ES6，我们也已经满地用着<code>Promise</code>了。</p>
<p>建议<strong>所有异步均使用Promise实现</strong>，以便在未来享受<code>async</code>和<code>await</code>关键字带来的便携性。</p>
<p>另外，虽然Babel可以转换<code>async</code>和<code>await</code>的代码，但<strong>不建议使用</strong>，因为转换出来的代码比较繁琐，且依赖于<code>generatorsRuntime</code>。</p>
<h3 id="各内置类型的方法增强">各内置类型的方法增强</h3>
<p>如<code>Array.from</code>、<code>String.prototype.repeat</code>等，这些方法都可以通过shim库支持，因此放心使用即可。</p>
<h3 id="二进制和八进制数字字面量">二进制和八进制数字字面量</h3>
<p>这个特性基本上是留给算法一族用的，因此我们的建议是<strong>除非数字本身在二/八进制下才有含义，否则不要使用</strong>。</p>
<h3 id="反射api">反射API</h3>
<p><code>Reflect</code>对象是ES6提供的反射对象，但其实没有什么方法是必要的。</p>
<p>其中的<code>delete(name)</code>和<code>has(name)</code>方法相当于<code>delete</code>和<code>in</code>运算符，而<code>defineProperty</code>等在<code>Object</code>上本身就有一套了，因此<strong>不建议使用该对象</strong>。</p>
<h3 id="尾递归">尾递归</h3>
<p>当作不存在就好了……</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ECMAScript6已经于近日进入了RC阶段，而早在其处于社区讨论时，我就开始一直在尝试使用ES6进行开发的方案。在<a href="https://babeljs.io">Babel</a>推出后，基于ES6的开发也有了具体可执行的解决方案，无论是Build还是Debug都能得到很好的支持。</p>
<p>而在有了充足的环境、工具之后，我们面临的是对ES6众多新特性的选择和分析，以便选取一个最佳的子集，让我们可以享受ES6带来的便利（减少代码量、提高可读性等）的同时，也可以顺利运行于当前以ES3-ES5为主的浏览器环境中。</p>
<p>经过分析后，本文试图对ES6各个特性得出是否适合应用的初步结论，并一一解释其使用场景。ES6的特性列表选自<a href="https://github.com/lukehoban/es6features">es6features</a>。</p>
<ul>
<li>★★★ 推荐使用</li>
<li>★★ 有考虑地使用</li>
<li>★ 慎重地使用</li>
<li>☆ 不使用</li>
</ul>
<table>
<thead>
<tr class="header">
<th align="left">特性</th>
<th align="center">推荐程度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">arrows</td>
<td align="center">★★★</td>
</tr>
<tr class="even">
<td align="left">classes</td>
<td align="center">★★★</td>
</tr>
<tr class="odd">
<td align="left">enhanced object literals</td>
<td align="center">★★★</td>
</tr>
<tr class="even">
<td align="left">template strings</td>
<td align="center">★★★</td>
</tr>
<tr class="odd">
<td align="left">destructuring</td>
<td align="center">★★</td>
</tr>
<tr class="even">
<td align="left">default + rest + spread</td>
<td align="center">★★★</td>
</tr>
<tr class="odd">
<td align="left">let + const</td>
<td align="center">★★★</td>
</tr>
<tr class="even">
<td align="left">iterators + for..of</td>
<td align="center">★★</td>
</tr>
<tr class="odd">
<td align="left">generators</td>
<td align="center">★</td>
</tr>
<tr class="even">
<td align="left">unicode</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">modules</td>
<td align="center">★★</td>
</tr>
<tr class="even">
<td align="left">module loaders</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">map + set + weakmap + weakset</td>
<td align="center">★★</td>
</tr>
<tr class="even">
<td align="left">proxies</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">symbols</td>
<td align="center">★</td>
</tr>
<tr class="even">
<td align="left">subclassable built-ins</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">promises</td>
<td align="center">★★★</td>
</tr>
<tr class="even">
<td align="left">math + number + string + array + object APIs</td>
<td align="center">★★★</td>
</tr>
<tr class="odd">
<td align="left">binary and octal literals</td>
<td align="center">★</td>
</tr>
<tr class="even">
<td align="left">reflect api</td>
<td align="center">☆</td>
</tr>
<tr class="odd">
<td align="left">tail calls</td>
<td align="center">★★</td>
</tr>
</tbody>
</table>
<p>接下来我们以上特性挨个进行介绍。需要关注一点：如果你不想使用shim库（如Babel的<code>browser-polyfill.js</code>和<code>generatorsRuntime.js</code>）或者想使用尽可能少的helper（Babel的<code>externalHelpers</code>配置），那么需要按你的需求进一步缩减可使用的ES6特性，如<code>Map</code>、<code>Set</code>这些就不应该使用。</p>]]>
    
    </summary>
    
      <category term="ECMAScript6" scheme="http://efe.baidu.com/tags/ECMAScript6/"/>
    
      <category term="ES6" scheme="http://efe.baidu.com/tags/ES6/"/>
    
      <category term="JavaScript" scheme="http://efe.baidu.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用FontEditor创建web字体图标]]></title>
    <link href="http://efe.baidu.com/blog/use-fonteditor-to-build-webfont/"/>
    <id>http://efe.baidu.com/blog/use-fonteditor-to-build-webfont/</id>
    <published>2015-05-18T16:00:00.000Z</published>
    <updated>2015-05-19T07:58:05.000Z</updated>
    <content type="html"><![CDATA[<p>关于web字体图标，市面上已经有一些好的在线工具来管理和生成，<code>iconfont</code>和<code>icomoon</code>都可以将svg图标转换成font图标以便在网页上使用。但是如果你想要更多：ttf、woff、eot、otf统统拿来用，svg、图片统统可导入，图标效果实时可调整，只需要在线动动鼠标，就可以完成呢。 那就需要一个好用的在线font编辑工具，<strong><a href="http://font.baidu.com/editor/" target="_blank" rel="external">FontEditor</a></strong>，你需要的东西都在这里。</p>
<a id="more"></a>
<h3 id="为什么会出现fonteditor">为什么会出现FontEditor</h3>
<blockquote>
<p>Everything Happens for a Reason</p>
</blockquote>
<p>FontEditor会出现只是因为我比较懒。如果我想用webfont做图标，又不想了解一大堆专业术语，又不想一次一次的导入和导出，又不想一次一次的调整fontsize以适应图标变化，又踏破铁鞋无觅处，那只能自己整一个了。FontEditor是一款<strong>纯前端</strong>字体编辑和管理软件，支持字体项目管理，支持导入ttf、woff、eot、otf格式字体，支持svg和图片导入，支持生成ttf、woff、eot、svg格式字体，支持批量调整字形和单个字形轮廓编辑，支持实时预览，支持实时同步字体到本地。</p>
<h3 id="如何使用svg制作webfont">如何使用svg制作webfont</h3>
<p>打开<code>chrome</code>浏览器，输入<a href="http://font.baidu.com/" class="uri" target="_blank" rel="external">http://font.baidu.com/</a>，创建名为<code>fonteditor</code>（看个人喜好）的项目，开始制作字体。</p>
<div class="figure">
<img src="/blog/use-fonteditor-to-build-webfont/img/new.png">
</div>
<p>在主菜单点击<code>导入-&gt;导入svg</code>按钮，打开文件选择框，拖选svg文件将svg图标导入到主面板；点击主面板<code>设置代码点</code>按钮，批量设置unicode代码点；点击主菜单<code>ttf</code>、<code>woff</code>、<code>zip</code>按钮，导出ttf、woff或其他格式字体；一个webfont制作完成，so easy。 保存项目，点击<code>预览</code>按钮查看图标预览，以及嵌入代码，如果你熟悉这一步，算我没说。</p>
<div class="figure">
<img src="/blog/use-fonteditor-to-build-webfont/img/import-svg.png">
</div>
<p>其他格式字形的导入，请参考FontEditor帮助文档，simple and stupid。</p>
<h3 id="如何调整字形">如何调整字形</h3>
<p>在主面板工具栏点击<code>调整位置</code>和<code>调整字形</code>按钮，对图标进行批量调整，也可以选中单个或多个字形进行单独调整。 这里需要普及一下相关知识： * <strong>左边轴</strong>：字形左边留白 * <strong>右边轴</strong>：字形右边留白，左右留白决定两个字形之间的间距 * <strong>基线</strong>：字体的baseline，对应于css中的<code>baseline</code> * <strong>上下边界</strong>：字体的ascent和descent，对应于css中的<code>text-top</code>和<code>text-bottom</code> * <strong>unicode代码点</strong>：Font Engine根据会代码点查找到相应的字形进行渲染，webfont可以使用私有区域 <code>0xE000</code>~<code>0XF8FF</code> 作为图标的代码点，详情：<a href="http://en.wikipedia.org/wiki/Unicode" target="_blank" rel="external">unicode</a></p>
<div class="figure">
<img src="/blog/use-fonteditor-to-build-webfont/img/glyf.png">
</div>
<h3 id="如何编辑单个字形">如何编辑单个字形</h3>
<p>对于webfont，使用FontEditor<strong>调整左右边轴为0，缩放字形到上下边界</strong>，即可满足大部分图标制作需求。如果需要精确调整字形，点击主面板字形上面的<code>铅笔</code>按钮可打开字形编辑面板，对单个字形进行调整： 拖选需要调整的轮廓，点击工具栏中的相关菜单可以对轮廓进行对齐、翻转、镜像、切割、求交、求并等操作，拖拽轮廓边界控制点调整轮廓大小。 双击单个轮廓进入轮廓点编辑模式，拖拽轮廓点改变字形，右键可增加、删除轮廓点，按<code>esc</code>退出轮廓点编辑。 点击工具栏中的<code>保存</code>按钮，保存当前轮廓。 按<code>F2</code>可以去切换<code>打开/关闭</code>字形编辑面板，也可以点击工具栏右侧的<code>退出</code>按钮退出字形编辑。</p>
<div class="figure">
<img src="/blog/use-fonteditor-to-build-webfont/img/adjust-contours.png">
</div>
<h3 id="如何同步字体到本地">如何同步字体到本地</h3>
<p>点击主面板工具栏<code>同步字体</code>按钮，设置同步选项。设置接收文件的服务地址，设置字体名称和需要同步的字体类型。在保存项目的时候FontEditor会发送数据到接收地址，然后就需要服务端接收字体数据。 关于如何保存FontEditor发送的字体，查看<a href="https://github.com/ecomfe/fonteditor/blob/master/demo/sync/font.php" target="_blank" rel="external">PHP版同步示例</a>。不会php？算我没说。</p>
<div class="figure">
<img src="/blog/use-fonteditor-to-build-webfont/img/sync.png">
</div>
<h3 id="脑补">脑补</h3>
<p>字体相关的文档和技术非常多，多到让人眼花缭乱无所适从，这里只列举了技术相关的文档，其他请自行补脑。</p>
<ul>
<li><a href="https://developer.apple.com/fonts/TrueType-Reference-Manual/RM02/Chap2.html" target="_blank" rel="external">The Font Engine</a> 字体引擎工作原理</li>
<li><a href="http://www.microsoft.com/typography/otspec/" target="_blank" rel="external">OpenType specification</a> OpenType官方文档</li>
<li><a href="http://www.w3.org/TR/2012/REC-WOFF-20121213/" target="_blank" rel="external">WOFF Font</a> WOFF字体格式</li>
<li><a href="http://www.w3.org/TR/SVG11/fonts.html" target="_blank" rel="external">SVG Font</a> SVG字体格式</li>
</ul>
<p>想贡献代码？移步这里： <iframe src="https://ghbtns.com/github-btn.html?user=ecomfe&repo=fonteditor&type=fork&count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe> 只想点个赞，在这： <iframe src="https://ghbtns.com/github-btn.html?user=ecomfe&repo=fonteditor&type=star&count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe></p>
<h3 id="相关项目">相关项目</h3>
<ul>
<li><a href="https://github.com/ecomfe/fontmin" target="_blank" rel="external">fontmin</a> 第一个纯 JS 字体解决方案</li>
<li><a href="https://github.com/kekee000/fonteditor-ttf" target="_blank" rel="external">fonteditor-ttf</a> FontEditor的nodejs版本基础库</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于web字体图标，市面上已经有一些好的在线工具来管理和生成，<code>iconfont</code>和<code>icomoon</code>都可以将svg图标转换成font图标以便在网页上使用。但是如果你想要更多：ttf、woff、eot、otf统统拿来用，svg、图片统统可导入，图标效果实时可调整，只需要在线动动鼠标，就可以完成呢。 那就需要一个好用的在线font编辑工具，<strong><a href="http://font.baidu.com/editor/">FontEditor</a></strong>，你需要的东西都在这里。</p>]]>
    
    </summary>
    
      <category term="font" scheme="http://efe.baidu.com/tags/font/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[VIM的JavaScript补全]]></title>
    <link href="http://efe.baidu.com/blog/vim-javascript-completion/"/>
    <id>http://efe.baidu.com/blog/vim-javascript-completion/</id>
    <published>2015-05-04T16:00:00.000Z</published>
    <updated>2015-05-05T00:36:16.000Z</updated>
    <content type="html"><![CDATA[<p>最近微软出了个Visual Studio Code，听说很diao，尤其是对JavaScript的补全支持很令人惊艳！</p>
<p>如果你是一个vim党，那么请淡定！</p>
<p>在JavaScript开发过程中，使用vim内置的<code>ins-completion</code>再加上一些插件，我们同样可以获得很牛逼的completion支持！</p>
<a id="more"></a>
<h2 id="ins-completion">ins-completion</h2>
<p>vim其实已经提供了很好的代码补全支持。</p>
<h3 id="整行">整行</h3>
<p>快捷键：<code>&lt;C-X&gt;&lt;C-L&gt;</code></p>
<div class="figure">
<img src="/blog/vim-javascript-completion/c-x-c-l.gif">
</div>
<h3 id="文件名">文件名</h3>
<p>快捷键：<code>&lt;C-X&gt;&lt;C-F&gt;</code></p>
<div class="figure">
<img src="/blog/vim-javascript-completion/c-x-c-f.gif">
</div>
<h3 id="当前文件中的关键字">当前文件中的关键字</h3>
<p>快捷键：<code>&lt;C-X&gt;&lt;C-P&gt;</code>或<code>&lt;C-X&gt;&lt;C-N&gt;</code></p>
<div class="figure">
<img src="/blog/vim-javascript-completion/c-x-c-pn.gif">
</div>
<h3 id="complete选项所指定的范围中的关键字"><code>complete</code>选项所指定的范围中的关键字</h3>
<p>快捷键：<code>&lt;C-N&gt;</code>或<code>&lt;C-P&gt;</code></p>
<div class="figure">
<img src="/blog/vim-javascript-completion/c-pn.gif">
</div>
<p><code>&lt;C-N&gt;</code>、<code>&lt;C-P&gt;</code>跟<code>&lt;C-X&gt;&lt;C-N&gt;</code>、<code>&lt;C-X&gt;&lt;C-P&gt;</code>类似，但是查找范围更广，不局限于当前文件。</p>
<p>如上图所示，我打开两个文件，在<code>src/echarts.js</code>中补全<code>src/component.js</code>中的关键字，就可以使用<code>&lt;C-N&gt;</code>或<code>&lt;C-P&gt;</code>。</p>
<p>具体查找范围由<code>complete</code>选项所规定，详见<code>:help E535</code>。</p>
<h3 id="dictionary中的关键字"><code>dictionary</code>中的关键字</h3>
<p>快捷键：<code>&lt;C-X&gt;&lt;C-K&gt;</code></p>
<p>假设你有一个<code>javascript.dict</code>文件，其内容如下： <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise&#10;Proxy&#10;let&#10;class&#10;extends</span><br></pre></td></tr></table></figure></p>
<p>设置<code>:set dictionary+=/path/to/es6.dict</code>之后就可以用<code>&lt;C-X&gt;&lt;C-K&gt;</code>来补全这些关键字了。</p>
<div class="figure">
<img src="/blog/vim-javascript-completion/c-x-c-k.gif">
</div>
<h3 id="omni-completion">omni completion</h3>
<p>快捷键：<code>&lt;C-X&gt;&lt;C-O&gt;</code></p>
<p>这个是基于语义上的补全，vim会猜测光标之前的关键词，然后给出补全。</p>
<div class="figure">
<img src="/blog/vim-javascript-completion/c-x-c-o.gif">
</div>
<p>更多补全方式，请看<code>:help ins-completion</code>。</p>
<h2 id="youcompleteme">YouCompleteMe</h2>
<p>按键太多了，真不开心…</p>
<p>先上一个自动打开候选菜单的插件，再继续吹牛逼吧…</p>
<p>YouCompleteMe是一个不错的选择，补全速度比neocomplete快。</p>
<p>基本配置如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let g:ycm_min_num_of_chars_for_completion = 3 </span><br><span class="line">let g:ycm_autoclose_preview_window_after_completion=1</span><br><span class="line">let g:ycm_complete_in_comments = 1</span><br><span class="line">let g:ycm_key_list_select_completion = ['&lt;c-n&gt;', '&lt;Down&gt;']</span><br><span class="line">let g:ycm_key_list_previous_completion = ['&lt;c-p&gt;', '&lt;Up&gt;']</span><br><span class="line">" 比较喜欢用tab来选择补全...</span><br><span class="line">function! MyTabFunction ()</span><br><span class="line">    let line = getline('.')</span><br><span class="line">    let substr = strpart(line, -1, col('.')+1)</span><br><span class="line">    let substr = matchstr(substr, "[^ \t]*$")</span><br><span class="line">    if strlen(substr) == 0</span><br><span class="line">        return "\&lt;tab&gt;"</span><br><span class="line">    endif</span><br><span class="line">    return pumvisible() ? "\&lt;c-n&gt;" : "\&lt;c-x&gt;\&lt;c-o&gt;"</span><br><span class="line">endfunction</span><br><span class="line">inoremap &lt;tab&gt; &lt;c-r&gt;=MyTabFunction()&lt;cr&gt;</span><br></pre></td></tr></table></figure>
<p>现在，对于关键字补全、路径补全、<code>omni completion</code>，YouCompleteMe可以自动打开补全菜单了。</p>
<div class="figure">
<img src="/blog/vim-javascript-completion/ycm.gif">
</div>
<p>恩，看起来<code>ins-completion</code>还不错，但是跟vscode比起来还不够！</p>
<p>vim的<code>omni completion</code>实际上可以支持更牛逼的completion，于是有了<a href="http://ternjs.net" target="_blank" rel="external">tern</a>。</p>
<h2 id="tern_for_vim">tern_for_vim</h2>
<p><code>tern_for_vim</code>是ternjs给vim量身定做的插件，它实际上是给javascript实现了一个新的<code>omnifunc</code>，叫做<code>tern#Complete</code>。</p>
<p>当我们按下<code>&lt;C-X&gt;&lt;C-O&gt;</code>时，vim实际上就是调用<code>omnifunc</code>。</p>
<p><code>tern_for_vim</code>改写了<code>omnifunc</code>，接管了vim的<code>omni completion</code>。</p>
<p>vim安装了<code>tern_for_vim</code>之后，在项目的根目录中新建一个配置文件<code>.tern-project</code>，以echarts为例，配置如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">libs</span>": <span class="value">[</span><br><span class="line">        <span class="string">"browser"</span></span><br><span class="line">    ]</span>,</span><br><span class="line">    "<span class="attribute">plugins</span>": <span class="value">&#123;</span><br><span class="line">        "<span class="attribute">requirejs</span>": <span class="value">&#123;</span><br><span class="line">            "<span class="attribute">baseUrl</span>": <span class="value"><span class="string">"./src"</span></span>,</span><br><span class="line">            "<span class="attribute">paths</span>": <span class="value">&#123;</span><br><span class="line">                "<span class="attribute">zrender</span>": <span class="value"><span class="string">"bower_components/zrender/src"</span></span><br><span class="line">            </span>&#125;</span><br><span class="line">        </span>&#125;</span><br><span class="line">    </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>libs</code>字段指明要导入哪些库，tern内置了以下几种库：</p>
<ul>
<li>browser</li>
<li>chai</li>
<li>ecma5，默认自动导入</li>
<li>ecma6</li>
<li>jquery</li>
<li>underscore</li>
</ul>
<p>我们现在只配置了browser，看看会发生什么事情？</p>
<div class="figure">
<img src="/blog/vim-javascript-completion/tern-browser.gif">
</div>
<p>如果你的项目还用到了jquery，那么你可以把jquery加到<code>.tern-project</code>的libs字段中，效果如下：</p>
<div class="figure">
<img src="/blog/vim-javascript-completion/tern-jquery.gif">
</div>
<p><code>plugins</code>更猛，可以补全模块化的代码，tern支持以下几种插件：</p>
<ul>
<li>angular.js</li>
<li>complete_string.js</li>
<li>component.js</li>
<li>doc_comment.js，默认自动启用</li>
<li>nodejs</li>
<li>requirejs</li>
</ul>
<p>看看echarts项目配置了requirejs插件之后会怎么样？</p>
<div class="figure">
<img src="/blog/vim-javascript-completion/tern-requirejs.gif">
</div>
<p>碉堡了，有木有！</p>
<p>我们再也不用担心某个模块到底提供了哪些方法，require它，输入点号，然后提示，你所要做的就是选择！</p>
<p>如果第三方库在代码中提供足够的文档注释，我们甚至都不需要再去查文档了！</p>
<p>哦，稍等，听说vscode还支持nodejs的补全。</p>
<p>在nodejs项目下配置一下<code>.tern-project</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">libs</span>": <span class="value">[]</span>,</span><br><span class="line">    "<span class="attribute">plugins</span>": <span class="value">&#123;</span><br><span class="line">        "<span class="attribute">node</span>": <span class="value">&#123;&#125;</span><br><span class="line">    </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>看看tern对nodejs项目的支持如何？</p>
<div class="figure">
<img src="/blog/vim-javascript-completion/tern-node.gif">
</div>
<p>嗯，貌似还可以！</p>
<h2 id="小结">小结</h2>
<p>如果你是一个vim粉丝，那希望本文对你有所帮助！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近微软出了个Visual Studio Code，听说很diao，尤其是对JavaScript的补全支持很令人惊艳！</p>
<p>如果你是一个vim党，那么请淡定！</p>
<p>在JavaScript开发过程中，使用vim内置的<code>ins-completion</code>再加上一些插件，我们同样可以获得很牛逼的completion支持！</p>]]>
    
    </summary>
    
      <category term="Completion" scheme="http://efe.baidu.com/tags/Completion/"/>
    
      <category term="JavaScript" scheme="http://efe.baidu.com/tags/JavaScript/"/>
    
      <category term="VIM" scheme="http://efe.baidu.com/tags/VIM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ECharts 发布 2.2.2]]></title>
    <link href="http://efe.baidu.com/blog/echarts-2.2.2/"/>
    <id>http://efe.baidu.com/blog/echarts-2.2.2/</id>
    <published>2015-04-29T16:00:00.000Z</published>
    <updated>2015-04-30T03:22:04.000Z</updated>
    <content type="html"><![CDATA[<p>在五一劳动节的前一天，ECharts发布了一个非常2的版本，2.2.2。在本版本中，我们一共做了以下重大升级：</p>
<ul>
<li>新增韦恩图(venn)及Treemap</li>
<li>发布 ECharts 在线构建工具</li>
<li>新增对数轴</li>
</ul>
<p>并且修复了一些反馈较多、优先级较高的问题：</p>
<ul>
<li>增加了大规模折线图添加数据抽希策略配置。<a href="https://github.com/ecomfe/echarts/issues/1370" target="_blank" rel="external">解决原有抽希策略导致的数据精度缺失问题</a></li>
<li>symbolSize 支持通过数组分别设置宽高</li>
<li>修复 <a href="https://github.com/ecomfe/echarts/issues/1308" target="_blank" rel="external">mac safari饼图性能问题</a></li>
<li>支持 z, zlevel 的配置</li>
</ul>
<a id="more"></a>
<h2 id="韦恩图">韦恩图</h2>
<p>韦恩图（维恩图），也叫文氏图，用于显示元素集合重叠区域的图示。诞生于1880年，韦恩（Venn）在《论命题和推理的图表化和机械化表现》一文中首次采用固定位置的交叉环形式用封闭曲线（内部区域）表示集合及其关系的图形。</p>
<div class="figure">
<img src="/blog/echarts-2.2.2/venn.jpg" alt="韦恩图"><p class="caption">韦恩图</p>
</div>
<p>可以通过访问ECharts官网的<a href="http://echarts.baidu.com/doc/example/venn.html" target="_blank" rel="external">示例</a>了解如何使用ECharts制作韦恩图</p>
<h2 id="treemap">Treemap</h2>
<p>这是一个中文名很长的图表类型，比如叫做：矩形式树状结构绘图法，或矩形式树状结构图绘制法，或者树状结构矩形图绘制法，或者甚至称为树状结构映射。其实指的是一种利用嵌套式矩形来显示树状结构数据的方法。</p>
<div class="figure">
<img src="/blog/echarts-2.2.2/treemap.jpg" alt="Treemap"><p class="caption">Treemap</p>
</div>
<p>可以通过访问ECharts官网的<a href="http://echarts.baidu.com/doc/example/treemap.html" target="_blank" rel="external">示例</a>了解如何使用ECharts制作Treemap。</p>
<h2 id="echarts在线发布工具">ECharts在线发布工具</h2>
<p>我们提供了最新的ECharts在线发布工具，方便用户可以自由的选择，仅仅打包你在项目中使用到的图表及组件代码。减少整体需要加载的ECharts文件大小，提高您产品的网络加载速度及用户体验。</p>
<p>入口最ECharts官网主导航的下载栏目中，或者直接访问 <a href="http://ecomfe.github.io/echarts-builder-web/" class="uri" target="_blank" rel="external">http://ecomfe.github.io/echarts-builder-web/</a></p>
<div class="figure">
<img src="/blog/echarts-2.2.2/pub.jpg" alt="发布工具"><p class="caption">发布工具</p>
</div>
]]></content>
    <summary type="html">
    <![CDATA[<p>在五一劳动节的前一天，ECharts发布了一个非常2的版本，2.2.2。在本版本中，我们一共做了以下重大升级：</p>
<ul>
<li>新增韦恩图(venn)及Treemap</li>
<li>发布 ECharts 在线构建工具</li>
<li>新增对数轴</li>
</ul>
<p>并且修复了一些反馈较多、优先级较高的问题：</p>
<ul>
<li>增加了大规模折线图添加数据抽希策略配置。<a href="https://github.com/ecomfe/echarts/issues/1370">解决原有抽希策略导致的数据精度缺失问题</a></li>
<li>symbolSize 支持通过数组分别设置宽高</li>
<li>修复 <a href="https://github.com/ecomfe/echarts/issues/1308">mac safari饼图性能问题</a></li>
<li>支持 z, zlevel 的配置</li>
</ul>]]>
    
    </summary>
    
      <category term="ECharts" scheme="http://efe.baidu.com/tags/ECharts/"/>
    
      <category term="数据可视化" scheme="http://efe.baidu.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[当我们谈论颜色时，我们在谈论什么 - 基础知识篇]]></title>
    <link href="http://efe.baidu.com/blog/what-we-talk-about-when-we-talk-about-color-basic/"/>
    <id>http://efe.baidu.com/blog/what-we-talk-about-when-we-talk-about-color-basic/</id>
    <published>2015-04-28T16:00:00.000Z</published>
    <updated>2015-04-29T04:28:24.000Z</updated>
    <content type="html"><![CDATA[<div class="figure">
<img src="/blog/what-we-talk-about-when-we-talk-about-color-basic/cover.png">
</div>
<p>谈到 <strong>颜色</strong>，前端工程师首先想起的便是基于 RGB 的 16 进制颜色代码，这也是我们工作中最常用到的 <strong>数值表示</strong> 方式。但是当我们的谈话再深入一些，话题远不止这些：</p>
<blockquote>
<p>前端：「我在 hackathon 时做了个网站，配色怎么看都丑，你帮我看看？」<br>设计：「这俩颜色不搭，光晕现象都出来了，还有把这里的饱和度调低一点，亮度调高一点。」<br>前端：「……」（你™在说什么！）</p>
</blockquote>
<p>这时你应该去向设计小伙伴要最熟悉的 16 进制颜色代码了，但被抱怨缺乏 <strong>设计感</strong> 的挫折还是有一点的。</p>
<p>想要和小伙伴愉快的交流下去，我们要了解颜色的「基础知识」，还要对「色彩空间」、「颜色搭配」、「颜色与情感」等各个方面都有些了解。<del>作为一个边看书边查百科的伪设计师，</del> 我想通过这个系列与大家一起从 <strong>颜色</strong> 开始，培养点 <strong>设计感</strong>。</p>
<p>本篇我们一起复习一下基础知识。</p>
<a id="more"></a>
<h2 id="原理">原理</h2>
<p>我们在中学的 <strong>物理</strong> 课上学过，颜色本质上是特定范围的 <a href="http://zh.wikipedia.org/wiki/电磁波" target="_blank" rel="external">电磁波</a>（如下图<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>）。</p>
<div class="figure">
<img src="/blog/what-we-talk-about-when-we-talk-about-color-basic/spectrum.png" alt="我们看到的色彩，是电磁波谱的一小部分"><p class="caption">我们看到的色彩，是电磁波谱的一小部分</p>
</div>
<p>但从 <strong>生理</strong> 来看，人们能看到颜色，是因为人类每只眼球视网膜大约有 600-700 万的 <a href="http://en.wikipedia.org/wiki/Cone_cell" target="_blank" rel="external">视锥细胞</a>，他们是处理可见光谱颜色的 <strong>感光器</strong><a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>。 人类的视锥细胞有三种，分别是 <strong>短波（S 或蓝色）视锥细胞</strong>、<strong>中波（M 或绿色）视锥细胞</strong>、<strong>长波（L 或红色）视锥细胞</strong>；这些视锥细胞响应的组合，让我们能够分辨出大约一千万种颜色。</p>
<h2 id="无障碍">无障碍</h2>
<p>我们能够看到色彩，是我们的 <em>身体硬件</em> 附带了相应功能的 <em>传感器</em>。其他生物与我们的 <em>硬件构造</em> 不同，看到的世界也是不同的，比如：大多数哺乳动物只有两种感光器，许多鸟类与有袋动物有四种感光器。</p>
<p>人类对颜色的感受也存在 <strong>较大</strong> 的 <strong>个体差异</strong>，根据网上的公开数据，色盲和色弱在人群中占有很大比率：</p>
<blockquote>
<p>红绿色盲人口占全球男性人口约 8%，女性人口约 0.5%，他们能看到多种颜色，但是会混淆识别某些颜色，尤其是红色与绿色。 另外全球约6%人口为三色视觉(色弱)，约 2% 人口为二色视觉(色盲)，极少数为单色视觉(全色盲)。</p>
<p>–维基百科<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
</blockquote>
<div class="figure">
<img src="/blog/what-we-talk-about-when-we-talk-about-color-basic/colorblind.png" alt="红、绿、蓝、黑 在人们眼中的样子"><p class="caption">红、绿、蓝、黑 在人们眼中的样子</p>
</div>
<p>所以我们在做 <strong>无障碍</strong> 产品的时候请将 <strong>色彩</strong> 的 <strong>可用性</strong> 也纳入考虑范围（比如数据可视化的色彩搭配）。<br>这里推荐一个叫做 <a href="https://chrome.google.com/webstore/detail/colorblinding/dgbgleaofjainknadoffbjkclicbbgaa" target="_blank" rel="external">Colorblinding</a> 的 Chrome 插件，你可以看看自己的作品，在 <strong>8%+ 的用户</strong> 眼中是什么样子的。</p>
<h2 id="原色">原色</h2>
<p>我们知道，<strong>原色</strong> 是指不能透过其他颜色的混合调配而得出的 <strong>基本色</strong>。<br><strong>原色</strong> 是个生物学的概念，所以我们看到 <strong>三原色</strong> 与我们三种类型的视锥细胞是基本吻合的。</p>
<p>有的同学会有疑惑，我小学美术老师教的三原色是 <strong>红</strong>、<strong>黄</strong>、<strong>蓝</strong> 又是怎么回事儿呢？<br>这得从 <strong>反射色</strong> 与 <strong>透过色</strong> 之间，不同的混色原理说起。</p>
<hr>
<p>以 <strong>反射光源</strong> 或 <strong>颜料着色</strong> 时使用的色彩，属于 <strong>消减型</strong> 的原色系统。</p>
<p>我们身边的物体大多数都无法自行发光，必须借助光源的 <strong>反射</strong> 才能被看见。 当光源照射物体时，对物体而言，可分为被吸收的波长与反射的波长，反射后的波长即是我们所看到的颜色。</p>
<p>CMYK（印刷四分色模式）是彩色印刷时采用的一种套色模式，它利用色料的 <strong>减色混合法</strong> 原理，加上黑色油墨<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>，共计四种颜色叠加，形成所谓 <strong>全彩印刷</strong>。 四种标准颜色是 <strong>青色（Cyan）</strong>、<strong>品红色（Magenta）</strong>、<strong>黄色（Yellow）</strong> 和 <strong>黑色（blacK）</strong>。</p>
<div class="figure">
<img src="/blog/what-we-talk-about-when-we-talk-about-color-basic/subtractive-primaries.png" alt="消减型原色系统"><p class="caption">消减型原色系统</p>
</div>
<p>对前端来说，我们的主要产出是用各种屏幕来展示的，CYMK 和我们关系不大，就不展开了。</p>
<hr>
<p>以 <strong>光源投射</strong> 时使用的色彩，属于 <strong>叠加型</strong> 的原色系统。</p>
<p>此系统中包含了 <strong>红</strong>、<strong>绿</strong>、<strong>蓝</strong> 三种原色，使用这三种原色可以产生其他颜色，例如红色与绿色混合可以产生黄色或橙色，绿色与蓝色混合可以产生青色，蓝色与红色混合可以产生紫色或品红色。 当这三种原色以等比例叠加在一起时，会变成灰色；若将此三原色的强度均调至最大并且等量重叠时，则会呈现白色。这套原色系统常被称为「RGB 色彩空间」。<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a></p>
<div class="figure">
<img src="/blog/what-we-talk-about-when-we-talk-about-color-basic/additive-primaries.png" alt="叠加型原色系统"><p class="caption">叠加型原色系统</p>
</div>
<p>电视、显示器、手机屏幕都是基于 <strong>RGB 色彩模型</strong> 来运转的，所以我们用 <code>RGB</code> 来表述颜色是最贴近硬件的方式。</p>
<p>很显然，作为前端的你已经非常熟悉 RGB 了。<br>你经常通过调整 <code>#RRGGBB</code> 中代表 红、绿、蓝 的值，调整设计细节；<br>你看到一个颜色的 HEX 代码就能够想象出它偏向哪种色彩，颜色是深是浅。<br>所以我也没必要再啰嗦一遍，耽误你们的时间。</p>
<h2 id="这些我都知道了然后呢">这些我都知道了，然后呢？</h2>
<p>用 <strong>RGB 色彩空间</strong> 调整颜色是让你 <strong>像显示器一样思考</strong>，或者 <strong>不思考</strong> 直接拿来用。</p>
<p>但我们设计时需要的是符合 <strong>语义</strong> 的、像人类一样思考的 <strong>色彩空间</strong>，比如：</p>
<ul>
<li>孟塞尔色彩空间 (HVC)：拥有一百多年历史，至今仍被广泛使用的系统</li>
<li>HSB (HSV)：各种图形应用程序中最常用的色彩空间</li>
<li>HSL：从 <a href="http://www.w3.org/TR/css3-color/#hsl-color" target="_blank" rel="external">CSS Color Module Level 3</a> 起支持的色彩空间</li>
<li>HWB：在 <a href="http://dev.w3.org/csswg/css-color/#the-hwb-notation" target="_blank" rel="external">CSS Color Module Level 4</a> 中将要支持的色彩空间</li>
<li>HuSL 与 HuSLp：改进了 HSL 的缺陷，用户友好的色彩空间</li>
</ul>
<p>上面这些内容我会在 <del>作者不忙的时候再写</del> 的本系列下一篇「色彩空间」中向大家介绍，本篇就到这里 <del>，因为听说博客太长没人看</del>。</p>
<p>最后，推荐一下 <a href="http://weibo.com/justineo" target="_blank" rel="external">Justineo</a> 同学写的颜色操作库 <a href="http://justineo.github.io/kolor/" target="_blank" rel="external">Kolor</a>，据说读懂源码看 <strong>下一篇</strong> 就会很轻松，路过就顺手给个 <strong>star</strong> 呗：</p>
<iframe src="https://ghbtns.com/github-btn.html?user=Justineo&amp;repo=kolor&amp;type=star&amp;count=true" frameborder="0" scrolling="0" width="170px" height="20px">
</iframe>
<h2 id="书目">书目</h2>
<p>以下是本系列博客的主要参考的书目，以及我根据 <strong>主观印象</strong> 给的评分，供参考。</p>
<ul>
<li><a href="http://dwz.cn/hacker-design" target="_blank" rel="external">黑客与设计：剖析设计之美的秘密</a>，评分：★★★★★，作者：[美] David Kadavy，ISBN：9787115345370</li>
<li><a href="http://dwz.cn/color-design" target="_blank" rel="external">色彩设计的原理</a>，评分：★★★★★，作者：[日] 伊达千代，ISBN：9787508629902</li>
<li><a href="http://dwz.cn/interaction-of-color" target="_blank" rel="external">色彩构成</a>，评分：★★★★☆，作者：[美] Josef Albers，ISBN：9787562463450</li>
<li><a href="http://dwz.cn/color-schemes" target="_blank" rel="external">配色设计原理</a>，评分：★★★☆☆，作者：[日] 奥博斯科编辑部，ISBN：9787500690351</li>
</ul>
<div class="footnotes">
<hr>
<ol>
<li id="fn1"><p>可见光谱在电磁波中的范围，原作者：<a href="http://en.wikipedia.org/wiki/File:EM_spectrum.svg" target="_blank" rel="external">Philip Ronan</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>视细胞中还有一种 <a href="http://en.wikipedia.org/wiki/Rod_cell" target="_blank" rel="external">视杆细胞</a>，他们在黑暗条件下比较敏感，但几乎不参与对颜色的处理。<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>来自维基百科「色盲」词条：<a href="http://zh.wikipedia.org/wiki/色盲" class="uri" target="_blank" rel="external">http://zh.wikipedia.org/wiki/色盲</a><a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>理论上只用上述三种颜色能够混合成黑色，但实际印刷时三种颜色的相加只能形成一种深灰色或深褐色。<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>来自维基百科「原色」词条：<a href="http://zh.wikipedia.org/wiki/原色" class="uri" target="_blank" rel="external">http://zh.wikipedia.org/wiki/原色</a><a href="#fnref5">↩</a></p></li>
</ol>
</div>
]]></content>
    <summary type="html">
    <![CDATA[<div class="figure">
<img src="/blog/what-we-talk-about-when-we-talk-about-color-basic/cover.png" />
</div>
<p>谈到 <strong>颜色</strong>，前端工程师首先想起的便是基于 RGB 的 16 进制颜色代码，这也是我们工作中最常用到的 <strong>数值表示</strong> 方式。但是当我们的谈话再深入一些，话题远不止这些：</p>
<blockquote>
<p>前端：「我在 hackathon 时做了个网站，配色怎么看都丑，你帮我看看？」<br />设计：「这俩颜色不搭，光晕现象都出来了，还有把这里的饱和度调低一点，亮度调高一点。」<br />前端：「……」（你™在说什么！）</p>
</blockquote>
<p>这时你应该去向设计小伙伴要最熟悉的 16 进制颜色代码了，但被抱怨缺乏 <strong>设计感</strong> 的挫折还是有一点的。</p>
<p>想要和小伙伴愉快的交流下去，我们要了解颜色的「基础知识」，还要对「色彩空间」、「颜色搭配」、「颜色与情感」等各个方面都有些了解。<del>作为一个边看书边查百科的伪设计师，</del> 我想通过这个系列与大家一起从 <strong>颜色</strong> 开始，培养点 <strong>设计感</strong>。</p>
<p>本篇我们一起复习一下基础知识。</p>]]>
    
    </summary>
    
      <category term="color" scheme="http://efe.baidu.com/tags/color/"/>
    
      <category term="前端设计感" scheme="http://efe.baidu.com/tags/%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%84%9F/"/>
    
      <category term="用户体验" scheme="http://efe.baidu.com/tags/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Fontmin 快速指南]]></title>
    <link href="http://efe.baidu.com/blog/fontmin-getting-started/"/>
    <id>http://efe.baidu.com/blog/fontmin-getting-started/</id>
    <published>2015-04-16T16:00:00.000Z</published>
    <updated>2015-04-17T04:57:41.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://ecomfe.github.io/fontmin/" target="_blank" rel="external">Fontmin</a> 是一个纯 JavaScript 实现的字体子集化方案。</p>
<p>提供了 <code>ttf</code> 子集化，<code>eot/woff/svg</code> 格式转换，<code>css</code> 生成 等功能，助推 webfont 发展，提升网页文字体验。</p>
<p data-height="350" data-theme-id="0" data-slug-hash="raEXBX" data-default-tab="result" data-user="firede" class="codepen">
See the Pen <a href="http://codepen.io/firede/pen/raEXBX/" target="_blank" rel="external">Fontmin Example</a> by Firede (<a href="http://codepen.io/firede" target="_blank" rel="external"><span class="citation">@firede</span></a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.
</p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>
<a id="more"></a>
<h2 id="why-fontmin">Why Fontmin</h2>
<p>浏览器的季风已撩拨起 webfont 的热浪，中文字体却依旧寂寞如雪。</p>
<p>与西文字体不同，由于字符集过大，中文字体无法享受 webfont 带来的便利。</p>
<p>为了让中文字体也乘上这道风，我们需要对其进行 <code>min</code>:</p>
<ul>
<li>子集化：提取字体中的部分字型，最小化打包字体</li>
<li>webfont 格式化：利用 <code>@font-face</code>，把自定义字体嵌入到网页中，支持 <code>ttf</code>、<code>woff</code>、<code>eot</code>、<code>svg</code> 等格式</li>
</ul>
<p>已有工具 <a href="https://code.google.com/p/sfntly/" target="_blank" rel="external">sfnttool.jar</a> (Java)，<a href="https://github.com/fontforge/fontforge" target="_blank" rel="external">Fontforge</a> (Python)，<a href="https://bitbucket.org/philip/font-optimizer/src/" target="_blank" rel="external">Font Optimizer</a> (Perl)，为什么还要造轮子呢?</p>
<blockquote>
<p>Any application that can be written in JavaScript, will eventually be written in JavaScript. – Jeff Atwood</p>
</blockquote>
<p>噗，开个玩笑。靠谱的说，是这样的：</p>
<ul>
<li>专注，面向前端工程师，专注字体的 web 应用</li>
<li>工程化，自动化开发流程，告别刀耕火种的人肉操作</li>
<li>社区，依靠社区的力量，可以有更多的玩法，如：<a href="http://efe.baidu.com/blog/chinese-font-build/" target="_blank" rel="external">edp-build-fontmin</a>, <a href="https://github.com/ecomfe/gulp-fontmin" target="_blank" rel="external">gulp-fontmin</a>, <a href="https://github.com/aui/font-spider" target="_blank" rel="external">font-spider</a></li>
</ul>
<p>以上，<a href="http://ecomfe.github.io/fontmin/" target="_blank" rel="external">Fontmin</a> 提供了多种方式，带你玩转字体。</p>
<h2 id="node-模块">node 模块</h2>
<p>npm 模块 <a href="https://www.npmjs.com/package/fontmin" target="_blank" rel="external">fontmin</a>，基于 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="external">stream</a> 处理字体文件，简单高效，方便扩展。可以与 <a href="https://github.com/gulpjs/gulp" target="_blank" rel="external">gulp</a> 插件 自由搭配。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Fontmin = <span class="keyword">require</span>(<span class="string">'fontmin'</span>);</span><br><span class="line"><span class="keyword">var</span> rename = <span class="keyword">require</span>(<span class="string">'gulp-rename'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fontmin = <span class="keyword">new</span> Fontmin()</span><br><span class="line">    .src(<span class="string">'fonts/big.ttf'</span>)</span><br><span class="line">    .<span class="keyword">use</span>(rename(<span class="string">'small.ttf'</span>));</span><br></pre></td></tr></table></figure>
<p>提供细粒度 <a href="https://github.com/ecomfe/fontmin#plugins" target="_blank" rel="external">plugins</a>，你可以自由定制专属的 webfont 压缩方案，比如：把字体转为 base64 嵌入到 css 中：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Fontmin = <span class="keyword">require</span>(<span class="string">'fontmin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fontmin = <span class="keyword">new</span> Fontmin()</span><br><span class="line">    .<span class="keyword">use</span>(Fontmin.css(&#123;</span><br><span class="line">        base64: <span class="keyword">true</span>		<span class="comment">// 开启 base64 嵌入，默认关闭</span></span><br><span class="line">    &#125;));</span><br></pre></td></tr></table></figure>
<p>输出 css：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">"eduSong"</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="function">url</span>(<span class="string">"eduSong.eot"</span>); <span class="comment">/* IE9 */</span></span><br><span class="line">    <span class="attribute">src</span>: <span class="function">url</span>(<span class="string">"eduSong.eot?#iefix"</span>) <span class="function">format</span>(<span class="string">"embedded-opentype"</span>), <span class="comment">/* IE6-IE8 */</span></span><br><span class="line">    <span class="function">url</span>(<span class="string">data:application/x-font-ttf;charset=utf-8;base64,AAEAAAAKAIAAAwA....</span>) <span class="function">format</span>(<span class="string">"truetype"</span>), <span class="comment">/* chrome、firefox、opera、Safari, Android，iOS 4.2+ */</span></span><br><span class="line">    <span class="function">url</span>(<span class="string">"eduSong.svg#eduSong"</span>) <span class="function">format</span>(<span class="string">"svg"</span>); <span class="comment">/* iOS 4.1- */</span></span><br><span class="line">    <span class="attribute">font-style</span>: normal;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为方便大家使用，提供一个最基本的 webfont 工作流 snippet：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Fontmin = <span class="keyword">require</span>(<span class="string">'fontmin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> srcPath = <span class="string">'src/font/*.ttf'</span>; <span class="comment">// 字体源文件</span></span><br><span class="line"><span class="keyword">var</span> destPath = <span class="string">'asset/font'</span>;    <span class="comment">// 输出路径</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'我说你是人间的四月天；笑响点亮了四面风；轻灵在春的光艳中交舞着变。'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">var</span> fontmin = <span class="keyword">new</span> Fontmin()</span><br><span class="line">    .src(srcPath)               <span class="comment">// 输入配置</span></span><br><span class="line">    .<span class="keyword">use</span>(Fontmin.glyph(&#123;        <span class="comment">// 字型提取插件</span></span><br><span class="line">        text: text              <span class="comment">// 所需文字</span></span><br><span class="line">    &#125;))</span><br><span class="line">    .<span class="keyword">use</span>(Fontmin.ttf2eot())     <span class="comment">// eot 转换插件</span></span><br><span class="line">    .<span class="keyword">use</span>(Fontmin.ttf2woff())    <span class="comment">// woff 转换插件     </span></span><br><span class="line">    .<span class="keyword">use</span>(Fontmin.ttf2svg())     <span class="comment">// svg 转换插件</span></span><br><span class="line">    .<span class="keyword">use</span>(Fontmin.css())         <span class="comment">// css 生成插件</span></span><br><span class="line">    .dest(destPath);            <span class="comment">// 输出配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line">fontmin.run(<span class="function"><span class="keyword">function</span> <span class="params">(err, files, stream)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;                  <span class="comment">// 异常捕捉</span></span><br><span class="line">        console.error(err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(<span class="string">'done'</span>);        <span class="comment">// 成功</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>大家可以这个基础上，自由扩展，玩法多多。</p>
<h2 id="命令行">命令行</h2>
<p>极客范儿? 就是喜欢弹奏键盘这种飘逸的感觉～</p>
<p>全局安装 fontmin</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g fontmin</span><br></pre></td></tr></table></figure>
<div class="figure">
<img src="/blog/fontmin-getting-started/img/terminal.png">
</div>
<h2 id="客户端">客户端</h2>
<p>懒得写代码? 直接把 <code>TTF</code> 拖进来，左侧输入需要文字，右侧实时看效果。点击生成，duang 一下，就搞定了~</p>
<div class="figure">
<img src="/blog/fontmin-getting-started/img/app.png">
</div>
<p>可以在 <a href="https://github.com/ecomfe/fontmin-app/releases" target="_blank" rel="external">这里</a> 找到最新版本。</p>
<h2 id="eof">EOF</h2>
<ul>
<li>本文封面：<a href="http://codepen.io/firede/pen/raEXBX" target="_blank" rel="external">Fontmin Example</a> by <span class="citation">[@Firede]</span>(http://weibo.com/firede)，<a href="http://codepen.io/lbebber/pen/dalKF" target="_blank" rel="external">Kinda Realistic Text</a> by <span class="citation">[@lucasbebber]</span>(https://twitter.com/lucasbebber)</li>
<li>字体支持：<a href="http://www.sentyfont.com/" target="_blank" rel="external">新蒂字体</a>，<a href="http://weibo.com/eonway" target="_blank" rel="external">浙江民间书刻体</a>，<a href="https://github.com/adobe-fonts/source-han-sans" target="_blank" rel="external">思源字体</a>，<a href="http://www.edu.tw/pages/detail.aspx?Node=3691&amp;Page=17009&amp;Index=6" target="_blank" rel="external">台湾教育部標準宋體</a></li>
</ul>
<p>如果您觉得 Fontmin 还不错，请给个 star 呗 ヾ(◍°∇°◍)ﾉﾞ</p>
<iframe src="https://ghbtns.com/github-btn.html?user=ecomfe&amp;repo=fontmin&amp;type=star&amp;count=true" frameborder="0" scrolling="0" width="170px" height="20px">
</iframe>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://ecomfe.github.io/fontmin/">Fontmin</a> 是一个纯 JavaScript 实现的字体子集化方案。</p>
<p>提供了 <code>ttf</code> 子集化，<code>eot/woff/svg</code> 格式转换，<code>css</code> 生成 等功能，助推 webfont 发展，提升网页文字体验。</p>
<p data-height="350" data-theme-id="0" data-slug-hash="raEXBX" data-default-tab="result" data-user="firede" class="codepen">
See the Pen <a href='http://codepen.io/firede/pen/raEXBX/'>Fontmin Example</a> by Firede (<a href='http://codepen.io/firede'><span class="citation">@firede</span></a>) on <a href='http://codepen.io'>CodePen</a>.
</p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>]]>
    
    </summary>
    
      <category term="font" scheme="http://efe.baidu.com/tags/font/"/>
    
      <category term="tool" scheme="http://efe.baidu.com/tags/tool/"/>
    
      <category term="中文字体" scheme="http://efe.baidu.com/tags/%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git submoudle vs git subtree]]></title>
    <link href="http://efe.baidu.com/blog/git-submodule-vs-git-subtree/"/>
    <id>http://efe.baidu.com/blog/git-submodule-vs-git-subtree/</id>
    <published>2015-04-13T16:00:00.000Z</published>
    <updated>2015-04-14T03:10:42.000Z</updated>
    <content type="html"><![CDATA[<p>先说结论：在项目模块拆分的时候，先考虑使用了 git submoudle 的方案，因为遇到一些问题，又研究了一下 git subtree 的方案，最后发现 git subtree 的成本更高，最后还是选择了 git submodule 的方案</p>
<p>git submodule 最初作为项目模块拆分时候的方案，在使用的过程中发现了几个问题：</p>
<ol style="list-style-type: decimal">
<li>同步代码比较麻烦</li>
<li>冲突解决起来不方便（因人而异）</li>
<li>有时候不确定是否应该PUSH本次的改动（主要是 new commits 的状态）</li>
<li>代码的重复性很高，占用硬盘（各个模块依赖的 common 和 dep 的体积很大，重复了很多次）</li>
</ol>
<p>查询了一些相关资料之后，看到有同学提到使用 git subtree 的一种解决方案，因此在bce-console/console上面弄了一个subtree的分支尝试了一下。</p>
<p>首先，我们还是把 bce-console/console 作为整个项目的集合来进行管理。</p>
<a id="more"></a>
<p>第一步：检出代码</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="attribute">http</span>:<span class="regexp">//gi</span>t.server/bce-<span class="built_in">console</span>/<span class="built_in">console</span>.git all-bce-<span class="built_in">console</span></span><br><span class="line">git checkout subtree</span><br></pre></td></tr></table></figure>
<p>此时我们发现，这个分支上面基本上什么都没有，src目录是空的</p>
<p>第二步：添加一些 remote</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add x-dep <span class="string">http:</span><span class="comment">//git.server/bce-console/dep.git</span></span><br><span class="line">git remote add x-mockup <span class="string">http:</span><span class="comment">//git.server/bce-console/mockup.git</span></span><br><span class="line">git remote add x-common <span class="string">http:</span><span class="comment">//git.server/bce-console/common.git</span></span><br></pre></td></tr></table></figure>
<p>后续我们就可以使用 x-dep 来代替 http://git.server/bce-console/dep.git 这个仓库了，就跟我们平时使用 origin 代替 http://git.server/bce-console/console.git 一样。</p>
<p>第三步：使用subtree添加目录</p>
<p>添加目录之前我们先把 x-dep, x-mockup, x-common 代码下载下来</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch x-<span class="keyword">common</span></span><br><span class="line">git fetch x-dep</span><br><span class="line">git fetch x-mockup</span><br></pre></td></tr></table></figure>
<p>现在就可以调用 subtree 命令了</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">git</span> <span class="comment">subtree</span> <span class="comment">add</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">prefix=dep</span> <span class="comment">x</span><span class="literal">-</span><span class="comment">dep</span> <span class="comment">master</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">squash</span></span><br><span class="line"><span class="comment">git</span> <span class="comment">subtree</span> <span class="comment">add</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">prefix=mockup</span> <span class="comment">x</span><span class="literal">-</span><span class="comment">mockup</span> <span class="comment">master</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">squash</span></span><br><span class="line"><span class="comment">git</span> <span class="comment">subtree</span> <span class="comment">add</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">prefix=src/common</span> <span class="comment">x</span><span class="literal">-</span><span class="comment">common</span> <span class="comment">master</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">squash</span></span><br></pre></td></tr></table></figure>
<p><code>--prefix</code> 就是我们要添加的那个目录，x-dep 就是前面 git remote 添加的那个地址，master 就是分支的名字</p>
<p>现在切换到 dep, mockup, src/common 目录去看看，应该发现已经有代码了吧</p>
<p>第四步：来是修改业务代码</p>
<p>假如我们要修改 bcc 模块的代码，可以参考类似前面的做法：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">add</span> x-bcc <span class="keyword">http</span>://git.server/bce-console/bcc.git</span><br><span class="line">git fetch x-bcc</span><br><span class="line">git subtree <span class="built_in">add</span> <span class="comment">--prefix=src/bcc x-bcc master</span></span><br></pre></td></tr></table></figure>
<p>好了，到此为止，代码都有了，开始干活。</p>
<p>不过干活之前，先备个份呗</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">push</span> origin subtree</span><br></pre></td></tr></table></figure>
<p>第五步：提交代码</p>
<p>吭哧吭哧开始写代码，把 dep, mockup, src/common, src/bcc 都修改了，改完之后本地也commit了，开始要push了，但是应该提交到哪里呢？</p>
<p>其实不要想那么多，直接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="operator"><span class="keyword">commit</span> -a -m ‘<span class="keyword">some</span> <span class="keyword">commit</span> message<span class="string">'</span><br><span class="line">git push origin subtree</span></span></span><br></pre></td></tr></table></figure>
<p>就把这些改动提交到了 bcc-console/console 的 subtree 分支。</p>
<p>但是这些改动并没有体现在 x-dep, x-common, x-mockup 的仓库，如果以后其他人 clone 了这些仓库，并没有看到我们改动，岂不是很麻烦，如果能想到这个问题，非常好，其实已经有解决方案了，就是使用 git subtree push。执行下面的命令：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree push <span class="comment">--prefix=src/bcc x-bcc subtree</span></span><br></pre></td></tr></table></figure>
<p>意思就是把最近的一些改动 push 到 x-bcc 这个仓库的 subtree 分支。</p>
<p>第六步：同步代码</p>
<p>既然前面提到了提交代码，就肯定会涉及到代码的同步，假如我直接修改了 x-mockup 仓库里面的数据，怎么同步过过来呢？其实方案跟上面的过程类似，首先需要把最新的代码拖下来，执行</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">git</span> fetch x-mockup</span><br></pre></td></tr></table></figure>
<p>然后就是</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">git</span> <span class="comment">subtree</span> <span class="comment">pull</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">prefix=mockup</span> <span class="comment">x</span><span class="literal">-</span><span class="comment">mockup</span> <span class="comment">master</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">squash</span></span><br></pre></td></tr></table></figure>
<h3 id="关于-squash">关于 squash</h3>
<p>如果细心的同学可能注意到了，前面 git subtree add 和 git subtree pull 的时候都有一个 squash 参数，这个参数是干啥的呢？我也不好解释，只能举个例子来说明：</p>
<p>假如我们在 x-mockup 上面提交了 10 个commit，如果没有 squash 参数，那么 git subtree pull 的时候，这 10 个commit 都会体现在 bce-console/console 的 git history 里面。</p>
<p>但是一般情况下，我同步代码的时候，并不关心 commit A 和 commit B 之间提交了哪些东西，我只关心从 commit A 升级到 commit B，此时加上 squash 参数就可以在 git history 里面只体现一个 commit。例如：</p>
<p>实际上 bbabe74 到 a8f8105 之间有 2 个commit，这个从 x-mockup 的 git history 里面可以看出来</p>
<p>但是因为我实际上是比较关心 x-bcc 的提交历史的，因此执行 git subtree add 时候，并没有带着 squash 参数，所以 x-bcc 这个仓库的历史都可以体现在 bce-console/console 这个仓库里面。</p>
<h3 id="faq">FAQ</h3>
<ol style="list-style-type: decimal">
<li>为啥搞得这么复杂？</li>
</ol>
<p>我（个人）感觉并不是特别复杂，我们面对的问题是一个很常见的模块复用的问题。git 里面默认集成的 submodule 和 subtree 自然有它的原因，学习使用这些工具来解决我们的问题，是很常见的一种方式。</p>
<ol start="2" style="list-style-type: decimal">
<li>为什么不考虑使用 symlink 的方式呢？</li>
</ol>
<p>通过软链接也是可以解决问题的，但是有两个弊端：第一个是在 Windows 平台上支持的程度有限（如果有其它方式，望不吝赐教）；另外一个问题是，如果我需要同步代码的话，就必须切换到 软链接 所在的目录，而不是直接使用 git subtree pull 来完成操作，还有就是如果改动了 软链接 所在目录的代码，也必须切换过去才能 push。</p>
<ol start="3" style="list-style-type: decimal">
<li>如果我想使用另外一个分支的内容，肿么办？</li>
</ol>
<p>前面我添加 x-common 的时候，用的是 master 分支。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree <span class="keyword">add</span> --prefix=src/<span class="built_in">common</span> x-<span class="built_in">common</span> master --squash</span><br></pre></td></tr></table></figure>
<p>如果这个分支上面有些 BUG，成阳修改之后先 PUSH 到了 x-common 仓库的 develop 分支，我应该如何切换到 develop 分支呢？其实方式很简单</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch x-<span class="built_in">common</span></span><br><span class="line">git rm -r src/<span class="built_in">common</span></span><br><span class="line">git commit -a -m ‘Before switch src/<span class="built_in">common</span> subtree branch<span class="string">'</span><br><span class="line">git subtree add --prefix=src/common x-common develop --squash</span></span><br></pre></td></tr></table></figure>
<p>主要的原理就是先删除，再加上。另外还有一种方式就是 git subtree pull 另外一个分支的名字</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree pull --prefix=src/<span class="keyword">common</span> x-<span class="keyword">common</span> develop --squash</span><br></pre></td></tr></table></figure>
<h3 id="使用-git-subtree-的时候遇到几个问题">使用 git subtree 的时候遇到几个问题</h3>
<p>按照上面的开发流程，本地的项目实际上可以正常的运行的，但是使用了一段儿时间之后，发现用 git subtree 管理这些模块有一些明显的劣势：</p>
<ol style="list-style-type: decimal">
<li>切换分支并不太方便</li>
</ol>
<p>因为我们使用 Gitlab 的 Merge Request 的功能来 Review 代码，大部分功能基本上都是在分支上面进行开发的，如果想要把本地某个目录的代码切换到某个分支，就需要执行<code>git rm -rf</code>和<code>git subtree add</code>的操作，明显没有<code>git checkout branch</code>来的方便</p>
<ol start="2" style="list-style-type: decimal">
<li>代码提交的速度问题</li>
</ol>
<p>我没有详细研究过 git 的原理，不太清楚为什么 git subtree push 的速度如此，其实 <a href="http://stackoverflow.com/questions/16134975/reduce-increasing-time-to-push-a-subtree" target="_blank" rel="external">SO</a> 上面也有人问过类似的问题，最终随着 commit 的记录越来越多，已经到了无法忍受的底部了，有的同学每次 push 需要花费几分钟的时间（当然跟设备的配置也有一定的关系），很影响工作效率</p>
<ol start="3" style="list-style-type: decimal">
<li>冲突的解决不太方便</li>
</ol>
<p>具体不方便在什么地方我也记得不是很清楚了</p>
<p>这几个问题相比最初使用 git submodule 遇到的问题而言，感觉使用 git submodule 遇到的那几个问题根本不是什么大问题了</p>
<ol style="list-style-type: decimal">
<li>同步代码比较麻烦</li>
</ol>
<p>自己写个简单的脚本来同步</p>
<p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/usr/bin/env bash</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line">git submodule update --remote</span><br><span class="line">git submodule -q foreach <span class="string">'pwd; git checkout -q master; git pull -q'</span></span><br></pre></td></tr></table></figure></p>
<ol start="2" style="list-style-type: decimal">
<li>冲突解决起来不方便（因人而异）</li>
</ol>
<p>发起 Merge Request 的同学自行解决冲突，Reviewer合并代码到 master 的时候如果有冲突就暂时不处理。这种机制保证了我们 master 分支的提交历史是很干净的，然后代码同步到 svn server 也很顺利。</p>
<ol start="3" style="list-style-type: decimal">
<li>有时候不确定是否应该PUSH本次的改动（主要是 new commits 的状态）</li>
</ol>
<p>new commits 就不要提交了</p>
<ol start="4" style="list-style-type: decimal">
<li>代码的重复性很高，占用硬盘（各个模块依赖的 common 和 dep 的体积很大，重复了很多次）</li>
</ol>
<p>调整了一下目录的结构，common 和 dep 从业务目录中提取出来，放到上一层目录，逻辑上还是存在的，比如请求 <code>/bcc/dep/xxx.js</code>的时候，让 <code>edp webserver</code>处理一下，从 <code>/dep/xxx.js</code>的位置读取文件，同样的对于<code>/bcc/common/yyy.js</code>也是同样的处理逻辑</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>先说结论：在项目模块拆分的时候，先考虑使用了 git submoudle 的方案，因为遇到一些问题，又研究了一下 git subtree 的方案，最后发现 git subtree 的成本更高，最后还是选择了 git submodule 的方案</p>
<p>git submodule 最初作为项目模块拆分时候的方案，在使用的过程中发现了几个问题：</p>
<ol style="list-style-type: decimal">
<li>同步代码比较麻烦</li>
<li>冲突解决起来不方便（因人而异）</li>
<li>有时候不确定是否应该PUSH本次的改动（主要是 new commits 的状态）</li>
<li>代码的重复性很高，占用硬盘（各个模块依赖的 common 和 dep 的体积很大，重复了很多次）</li>
</ol>
<p>查询了一些相关资料之后，看到有同学提到使用 git subtree 的一种解决方案，因此在bce-console/console上面弄了一个subtree的分支尝试了一下。</p>
<p>首先，我们还是把 bce-console/console 作为整个项目的集合来进行管理。</p>]]>
    
    </summary>
    
      <category term="git" scheme="http://efe.baidu.com/tags/git/"/>
    
      <category term="submoudle" scheme="http://efe.baidu.com/tags/submoudle/"/>
    
      <category term="subtree" scheme="http://efe.baidu.com/tags/subtree/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Web移动端Fixed布局的解决方案]]></title>
    <link href="http://efe.baidu.com/blog/mobile-fixed-layout/"/>
    <id>http://efe.baidu.com/blog/mobile-fixed-layout/</id>
    <published>2015-04-02T16:00:00.000Z</published>
    <updated>2015-04-03T03:23:25.000Z</updated>
    <content type="html"><![CDATA[<p>移动端业务开发，iOS 下经常会有 fixed 元素和输入框(input 元素)同时存在的情况。 但是 fixed 元素在有软键盘唤起的情况下，会出现许多莫名其妙的问题。 这篇文章里就提供一个简单的有输入框情况下的 fixed 布局方案。</p>
<a id="more"></a>
<hr>
<h3 id="ios下的-fixed-input-bug现象">iOS下的 Fixed + Input BUG现象</h3>
<p>让我们先举个栗子，最直观的说明一下这个 BUG 的现象。 常规的 fixed 布局，可能使用如下布局（以下仅示意代码）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">body</span> <span class="attribute">class</span>=<span class="value">"layout-fixed"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- fixed定位的头部 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">header</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="title">header</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 可以滚动的区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">main</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 内容在这里... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">main</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- fixed定位的底部 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">placeholder</span>=<span class="value">"Footer..."</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">button</span> <span class="attribute">class</span>=<span class="value">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对应的样式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">header</span>, <span class="tag">footer</span>, <span class="tag">main</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">header</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> fixed</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">50px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">footer</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> fixed</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">34px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">main</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">50px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin-bottom</span>:<span class="value"> <span class="number">34px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">2000px</span></span><br><span class="line"></span></span></span>&#125;</span><br></pre></td></tr></table></figure>
<p>然后看起来就是下面这个样子。拖动页面时 header 和 footer 已经定位在了对应的位置，目测没问题了。</p>
<div class="figure">
<img src="/blog/mobile-fixed-layout/img/fixed.png" title="fixed page" alt="fixed定位"><p class="caption">fixed定位</p>
</div>
<p>但接下来问题就来了！如果底部输入框软键盘被唤起以后，再次滑动页面，就会看到如下图所示：</p>
<p><img src="/blog/mobile-fixed-layout/img/fixed_bug_0.png" title="fixed page" alt="fixed定位"> <img src="/blog/mobile-fixed-layout/img/fixed_bug_1.png" title="fixed page" alt="fixed定位"></p>
<p>我们看到 fixed 定位好的元素跟随页面滚动了起来… fixed 属性失效了！</p>
<p>这是为什么呢？简单解释下： &gt; <strong>软键盘唤起后，页面的 fixed 元素将失效（即无法浮动，也可以理解为变成了 absolute 定位），所以当页面超过一屏且滚动时，失效的 fixed 元素就会跟随滚动了。</strong></p>
<p>这便是 iOS 上 fixed 元素和输入框的 bug 。其中不仅限于 <code>type=text</code> 的输入框，凡是软键盘（比如时间日期选择、select 选择等等）被唤起，都会遇到同样地问题。</p>
<hr>
<p>虽然 <code>isScroll.js</code> 可以很好的解决 fixed 定位滚动的问题，但是不在万不得已的情况下，我们尽量尝试一下不依赖第三方库的布局方案，以简化实现方式。这里抛砖引玉作为参考。</p>
<h3 id="解决思路">解决思路：</h3>
<p>既然在 iOS 下由于软键盘唤出后，页面 fixed 元素会失效，导致跟随页面一起滚动，那么<strong>假如——页面不会过长出现滚动，那么即便 fixed 元素失效，也无法跟随页面滚动，也就不会出现上面的问题了</strong>。</p>
<p>那么按照这个思路，如果使 fixed 元素的父级不出现滚动，而将原 body 滚动的区域域移到 main 内部，而 header 和 footer 的样式不变，代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">body</span> <span class="attribute">class</span>=<span class="value">"layout-scroll-fixed"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- fixed定位的头部 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">header</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="title">header</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 可以滚动的区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">main</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"content"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 内容在这里... --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">main</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- fixed定位的底部 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">placeholder</span>=<span class="value">"Footer..."</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">button</span> <span class="attribute">class</span>=<span class="value">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">header</span>, <span class="tag">footer</span>, <span class="tag">main</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">header</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> fixed</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">50px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">footer</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> fixed</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">34px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">main</span> <span class="rules">&#123;</span><br><span class="line">    <span class="comment">/* main绝对定位，进行内部滚动 */</span></span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">50px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">34px</span></span></span>;</span><br><span class="line">    <span class="comment">/* 使之可以滚动 */</span></span><br><span class="line">    <span class="rule"><span class="attribute">overflow-y</span>:<span class="value"> scroll</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">main</span> <span class="class">.content</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">2000px</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>这样再来看一下：</p>
<div class="figure">
<img src="/blog/mobile-fixed-layout/img/fixed_scroll_0.png" title="fixed page" alt="fixed定位"><p class="caption">fixed定位</p>
</div>
<p>在原始输入法下， fixed 元素可以定位在页面的正确位置。滚动页面时，由于滚动的是 main 内部的 div，因此 footer 没有跟随页面滚动。</p>
<p>上面貌似解决了问题，但是如果在手机上实际测试一下，会发现 main 元素内的滚动非常不流畅，滑动的手指松开后，滚动立刻停止，失去了原本的流畅滚动特性。百度一下弹性滚动的问题，发现在 <code>webkit</code> 中，下面的属性可以恢复弹性滚动。</p>
<blockquote>
<p>-webkit-overflow-scrolling: touch;</p>
</blockquote>
<p>在 main 元素上加上该属性，嗯，丝般顺滑的感觉又回来了！</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">main</span> <span class="rules">&#123;</span><br><span class="line">    <span class="comment">/* main绝对定位，进行内部滚动 */</span></span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">50px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">34px</span></span></span>;</span><br><span class="line">    <span class="comment">/* 使之可以滚动 */</span></span><br><span class="line">    <span class="rule"><span class="attribute">overflow-y</span>:<span class="value"> scroll</span></span>;</span><br><span class="line">    <span class="comment">/* 增加该属性，可以增加弹性 */</span></span><br><span class="line">    <span class="rule"><span class="attribute">-webkit-overflow-scrolling</span>:<span class="value"> touch</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>另外，这里的 header 和 footer 使用的是 fixed 定位，如果考虑到更老一些的 iOS 系统不支持 fixed 元素，完全可以把 fixed 替换成 absolute 。测试后效果是一样的。</p>
<p>至此一个不依赖第三方库的 fixed 布局就完成了。</p>
<hr>
<h3 id="android-下布局">Android 下布局</h3>
<p>谈到了 iOS ，也来简单说一下 Android 下的布局吧。</p>
<p>在 Android2.3+ 中，因为不支持 overflow-scrolling ，因此部分浏览器内滚动会有不流畅的卡顿。但是目前发现在 body 上的滚动还是很流畅的，因此使用第一种在 iOS 出现问题的 fixed 定位的布局就可以了。</p>
<p>如果需要考虑 Android2.3 以下系统，因为不支持 fixed 元素，所以依然要需要考虑使用 <code>isScroll.js</code> 来实现内部滚动。</p>
<p>其实在 fixed 和输入框的问题上，基本思路就是： &gt; 由于 fixed 在软键盘唤起后会失效，导致在页面可以滚动时，会跟随页面一起滚动。因此如果页面无法滚动，那么 fixed 元素即使失效，也不会滚动，也就不会出现 bug 了。</p>
<p>所以可以在这个方面去考虑解决问题。</p>
<hr>
<h3 id="其他的一些细节处理">其他的一些细节处理</h3>
<p>在细节处理上，其实还有很多要注意的，挑几个实际遇到比较大的问题来说一下：</p>
<ol style="list-style-type: decimal">
<li>有时候输入框 focus 以后，会出现软键盘遮挡输入框的情况，这时候可以尝试 input 元素的 scrollIntoView 进行修复。</li>
<li>在 iOS 下使用第三方输入法时，输入法在唤起经常会盖住输入框，只有在输入了一条文字后，输入框才会浮出。目前也不知道有什么好的办法能让唤起输入框时正确显示。这暂时算是 iOS 下的一个坑吧。</li>
<li>有些第三方浏览器底部的工具栏是浮在页面之上的，因此底部 fixed 定位会被工具栏遮挡。解决办法也比较简单粗暴——适配不同的浏览器，调整 fixed 元素距离底部的距离。</li>
<li>最好将 header 和 footer 元素的 touchmove 事件禁止，以防止滚动在上面触发了部分浏览器全屏模式切换，而导致顶部地址栏和底部工具栏遮挡住 header 和 footer 元素。</li>
<li><p>在页面滚动到上下边缘的时候，如果继续拖拽会将整个 View 一起拖拽走，导致页面的“露底”。</p>
<div class="figure">
<img src="/blog/mobile-fixed-layout/img/fixed_pull_over.png" title="fixed page" alt="fixed定位"><p class="caption">fixed定位</p>
</div></li>
</ol>
<p>为了防止页面露底，可以在页面拖拽到边缘的时候，通过判断拖拽方向以及是否为边缘来阻止 touchmove 事件，防止页面继续拖拽。</p>
<p>以上面内滚动 <code>layout-scroll-fixed</code> 布局为例，给出一段代码作为参考： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止内容区域滚到底后引起页面整体的滚动</span></span><br><span class="line"><span class="keyword">var</span> content = <span class="built_in">document</span>.querySelector(<span class="string">'main'</span>);</span><br><span class="line"><span class="keyword">var</span> startY;</span><br><span class="line"></span><br><span class="line">content.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>&#123;</span><br><span class="line">    startY = e.touches[<span class="number">0</span>].clientY;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">content.addEventListener(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 高位表示向上滚动</span></span><br><span class="line">    <span class="comment">// 底位表示向下滚动</span></span><br><span class="line">    <span class="comment">// 1容许 0禁止</span></span><br><span class="line">    <span class="keyword">var</span> status = <span class="string">'11'</span>;</span><br><span class="line">    <span class="keyword">var</span> ele = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentY = e.touches[<span class="number">0</span>].clientY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ele.scrollTop === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果内容小于容器则同时禁止上下滚动</span></span><br><span class="line">        status = ele.offsetHeight &gt;= ele.scrollHeight ? <span class="string">'00'</span> : <span class="string">'01'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ele.scrollTop + ele.offsetHeight &gt;= ele.scrollHeight) &#123;</span><br><span class="line">        <span class="comment">// 已经滚到底部了只能向上滚动</span></span><br><span class="line">        status = <span class="string">'10'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status != <span class="string">'11'</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断当前的滚动方向</span></span><br><span class="line">        <span class="keyword">var</span> direction = currentY - startY &gt; <span class="number">0</span> ? <span class="string">'10'</span> : <span class="string">'01'</span>;</span><br><span class="line">        <span class="comment">// 操作方向和当前允许状态求与运算，运算结果为0，就说明不允许该方向滚动，则禁止默认事件，阻止滚动</span></span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">parseInt</span>(status, <span class="number">2</span>) &amp; <span class="built_in">parseInt</span>(direction, <span class="number">2</span>))) &#123;</span><br><span class="line">            stopEvent(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>移动端业务开发，iOS 下经常会有 fixed 元素和输入框(input 元素)同时存在的情况。 但是 fixed 元素在有软键盘唤起的情况下，会出现许多莫名其妙的问题。 这篇文章里就提供一个简单的有输入框情况下的 fixed 布局方案。</p>]]>
    
    </summary>
    
      <category term="Layout" scheme="http://efe.baidu.com/tags/Layout/"/>
    
      <category term="Mobile" scheme="http://efe.baidu.com/tags/Mobile/"/>
    
      <category term="fixed" scheme="http://efe.baidu.com/tags/fixed/"/>
    
      <category term="弹性滚动" scheme="http://efe.baidu.com/tags/%E5%BC%B9%E6%80%A7%E6%BB%9A%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ECharts基础教程视频发布]]></title>
    <link href="http://efe.baidu.com/blog/echarts-course/"/>
    <id>http://efe.baidu.com/blog/echarts-course/</id>
    <published>2015-03-26T16:00:00.000Z</published>
    <updated>2015-05-05T00:11:02.000Z</updated>
    <content type="html"><![CDATA[<div class="figure">
<img src="/blog/echarts-course/ec.jpg">
</div>
<p><a href="http://echarts.baidu.com" target="_blank" rel="external">ECharts</a>的创始人，<a href="http://weibo.com/u/1808084593" target="_blank" rel="external">Kener-林峰</a>在网易云课堂上发布了<a href="http://study.163.com/course/courseMain.htm?courseId=1016007" target="_blank" rel="external">《ECharts基础教程》</a>视频，定价<code>99元</code>。是的，你没看错，这次不是免费的。</p>
<p>在EFE，我们要求所有业务无关的技术产品必须开源。我们知道即使开源也可能没什么人会和你一起玩，但开源代表的是我们开放的态度，欢迎别人一起玩，欢迎大家用，更欢迎大家监督，这对我们自己也是一种鞭策。所以ECharts一开始就是开源的，而且是BSD协议，可以免费用在任何地方。相比之下，HighCharts商业使用是要收费的，这是越来越多的用户开始使用ECharts的原因之一。但是更重要的，ECharts能有今天的成绩，是因为林峰。</p>
<p>作为林峰的战友，我目睹了他在这两年多来的努（wan）力（ming）。我经常能够看到他晚上两点im工具的头像还是亮的。有时候他会凌晨三四点钟梦到一个feature，兴奋得睡不着，又为了不打扰到家人，就开车到公司来干。这时候公司的地下停车场还没开门，车就只能停在地上。我相信这是梦想和他本身的热情。</p>
<p>和很多技术geek不同，他很注重技术产品的API易用性。大家在谈论一个lib怎么拆分才能更好扩展的时候，他会更关注提供的API是怎样别人用的才更舒服。我也看到很多技术产品本身很厉害但是例子和文档都不全导致感兴趣的人无从下手，这些脏活累活的周边重要度甚至超过了产品本身，但技术人员往往排斥这些事情。他和别人不同，他花费了很大的时间和精力去制作了ECharts的官网、文档、上百个例子、还有《Why ECharts》的展示页。这也是ECharts能有这么多用户的重要因素。我一直想用static site generator去重构ECharts的官网，但看着这么多页面，最终还是没有找到勇气和足够大块的时间下手。</p>
<p>他能够把握ECharts每个feature发布的时间，每次发布都有很多独有的亮点，能吸引不少用户。当然这都是后话，对他而言，心里的想法很多，就是做一些，发布一版，再做一些，再发布，很自然的事情。</p>
<p>从发布1.0、2.0、再上了GitHub Explore后，ECharts的用户呈现了爆发式的增长，每天收到的开源中国、GitHub issue、邮件都有很多，而且很大一部分是问一些比较显而易见能够在官网上找到答案或例子的问题。我对ECharts的使用不熟，只能回一些简单的问题，光是“ECharts商用是不是免费”的邮件我已经回过好多封了。我看到林峰每天依旧很忙，但是ECharts的进步速度确实在放慢，他每天花很多时间在回复一些显而易见的问题上。然后他和我说，太多重复的问题了，我要做一个视频教程系列，以后就不用回答这些问题了。所以大家可以看到，<a href="http://study.163.com/course/courseMain.htm?courseId=1016007" target="_blank" rel="external">《ECharts基础教程》</a>的第一篇就是《如何使用官网》。</p>
<p>人可以有不止一个梦想。两周以前，林峰离开了EFE，离开了数据可视化，去追逐更高的梦想和天空。然后他发出了在春节放假期间录制的<a href="http://study.163.com/course/courseMain.htm?courseId=1016007" target="_blank" rel="external">《ECharts基础教程》</a>，定价<code>99元</code>。我们讨论过这个问题，我个人觉得他定价是比较低的，现在的物价请人吃饭都要至少一百块。我们相信：</p>
<ul>
<li>还是有人愿意为了知识买单的。</li>
<li>如果你花钱了，你就会有动力去看完。免费的东西会有很多人不珍惜。自己约的x就要努力x完。</li>
<li>如果你觉得贵，就当是买了一份ECharts咯。ECharts的用户大多是工程师。如果工程师自己都不愿意为技术产品买单，谁会为你的劳动买单呢？</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<div class="figure">
<img src="/blog/echarts-course/ec.jpg">
</div>
<p><a href="http://echarts.baidu.com" target="_blank" rel="external">ECh]]>
    </summary>
    
      <category term="ECharts" scheme="http://efe.baidu.com/tags/ECharts/"/>
    
      <category term="数据可视化" scheme="http://efe.baidu.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再谈 CSS 预处理器]]></title>
    <link href="http://efe.baidu.com/blog/revisiting-css-preprocessors/"/>
    <id>http://efe.baidu.com/blog/revisiting-css-preprocessors/</id>
    <published>2015-03-17T16:00:00.000Z</published>
    <updated>2015-03-27T02:23:42.000Z</updated>
    <content type="html"><![CDATA[<p>CSS 预处理器是什么？一般来说，它们基于 CSS 扩展了一套属于自己的 DSL，来解决我们书写 CSS 时难以解决的问题：</p>
<ul>
<li>语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；</li>
<li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以<strong>字面量</strong>的形式重复输出，导致难以维护。</li>
</ul>
<p>所以这就决定了 CSS 预处理器的主要目标：提供 CSS 缺失的<em>样式层</em>复用机制、减少冗余代码，提高样式代码的可维护性。这不是锦上添花，而恰恰是<em>雪中送炭</em>。</p>
<p>网上已经有不少对比目前最主流的三个预处理器 Less、Sass 和 Stylus（按字母顺序排名）的文章了，但是似乎都不是很详细，或者内容有些过时。下面我会更详细地探讨一下这三种预处理器的特性和它们的差异。</p>
<p>下面主要会分为如下几方面来讨论：</p>
<ul>
<li>基本语法</li>
<li>嵌套语法</li>
<li>变量</li>
<li><span class="citation">@import</span></li>
<li>混入</li>
<li>继承</li>
<li>函数</li>
<li>逻辑控制</li>
</ul>
<p>事先声明一下，平时我在开发中主要使用的是 Less，所以可能对 Sass 和 Stylus 的熟悉程度稍差一些，比较时主要参考三者官网的语言特性说明，有一些正在开发的功能可能会遗漏。</p>
<p>本文中对 CSS 语法的话术与 MDN 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Syntax" target="_blank" rel="external">CSS 语法</a>介绍一致。</p>
<a id="more"></a>
<h2 id="基本语法">基本语法</h2>
<p>Less 的基本语法属于「CSS 风格」，而 Sass、Stylus 相比之下激进一些，利用缩进、空格和换行来减少需要输入的字符。不过区别在于 Sass、Stylus 同时也兼容「CSS 风格」代码。多一种选择在更灵活的同时，在团队开发中也免不了增加更多约定来保持风格统一。而对个人而言，语法风格按自己口味选择即可。</p>
<p><strong>注：后面的 Sass 代码会用被更多人接受的 SCSS 风格给出。</strong></p>
<p>Less &amp; SCSS： <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Sass： <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.box</span></span><br><span class="line">  <span class="attribute">display</span><span class="value">: block</span></span><br></pre></td></tr></table></figure></p>
<p>Stylus： <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.box</span></span><br><span class="line">  <span class="attribute">display</span>: block</span><br></pre></td></tr></table></figure></p>
<h2 id="嵌套语法">嵌套语法</h2>
<p>三者的嵌套语法都是一致的，甚至连引用父级选择器的标记 <code>&amp;</code> 也相同。区别只是 Sass 和 Stylus 可以用没有大括号的方式书写。以 Less 为例：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.a</span> &#123;</span><br><span class="line">  <span class="keyword">&amp;</span><span class="class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的 CSS 为： <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.a</span><span class="class">.b</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>除了规则集的嵌套，Sass 额外提供了一个我个人认为比较另（jī）类（lèi）的「属性嵌套」： <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.funky</span> &#123;</span><br><span class="line">  <span class="attribute">font</span><span class="value">: &#123;</span><br><span class="line">    family: fantasy;</span></span><br><span class="line">    size<span class="value">: <span class="number">30em</span>;</span></span><br><span class="line">    weight<span class="value">: bold;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="选择器引用">选择器引用</h3>
<p>三者都支持用 <code>&amp;</code> 在嵌套的规则集中引用上层的选择器，这可以是嵌套书写 CSS 时的「惯例」了。语法相同，但是逻辑上有些许差异。在一个选择器中用两次以上 <code>&amp;</code> 且父选择器是一个列表时，Less 会对选择器进行排列组合，而 Sass 和 Stylus 不会这么做。</p>
<p>也就是说，假设上层选择器为 <code>.a, .b</code>，则内部的 <code>&amp; &amp;</code> 在 Less 中会成为 <code>.a .a, .a .b, .b .a, .b .b</code>，而 Sass 和 Stylus 则输出 <code>.a .a, .b .b</code>。</p>
<p>假设我们要用预处理器书写 <a href="https://html.spec.whatwg.org/multipage/rendering.html#sections-and-headings" target="_blank" rel="external">WHATWG 推荐的 section 标题样式</a>，在 Less 中可以方便地书写为：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">article</span>, <span class="tag">aside</span>, <span class="tag">nav</span>, <span class="tag">section</span> &#123;</span><br><span class="line">  <span class="tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0.83em</span>; <span class="attribute">margin-bottom</span>: <span class="number">0.83em</span>; <span class="attribute">font-size</span>: <span class="number">1.50em</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">&amp;</span> <span class="keyword">&amp;</span> <span class="tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">1.00em</span>; <span class="attribute">margin-bottom</span>: <span class="number">1.00em</span>; <span class="attribute">font-size</span>: <span class="number">1.17em</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">&amp;</span> <span class="keyword">&amp;</span> <span class="keyword">&amp;</span> <span class="tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">1.33em</span>; <span class="attribute">margin-bottom</span>: <span class="number">1.33em</span>; <span class="attribute">font-size</span>: <span class="number">1.00em</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">&amp;</span> <span class="keyword">&amp;</span> <span class="keyword">&amp;</span> <span class="keyword">&amp;</span> <span class="tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">1.67em</span>; <span class="attribute">margin-bottom</span>: <span class="number">1.67em</span>; <span class="attribute">font-size</span>: <span class="number">0.83em</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">&amp;</span> <span class="keyword">&amp;</span> <span class="keyword">&amp;</span> <span class="keyword">&amp;</span> <span class="keyword">&amp;</span> <span class="tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">2.33em</span>; <span class="attribute">margin-bottom</span>: <span class="number">2.33em</span>; <span class="attribute">font-size</span>: <span class="number">0.67em</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这个推荐样式十分脑残，编译出来的结果会有 47KB 之巨，根本不可用，这里只是借来演示一下。</p>
<p>除了 <code>&amp;</code>，Sass 和 Stylus 更进一步，分别用 <code>@at-root</code> 和 <code>/</code> 符号作为嵌套时「根」规则集的选择器引用。这有什么用呢？举个例子，假设 HTML 结构是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">article</span> <span class="attribute">class</span>=<span class="value">"post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">h1</span>&gt;</span>我是一篇文章<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">h1</span> <span class="attribute">class</span>=<span class="value">"section-title"</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#s1"</span> <span class="attribute">class</span>=<span class="value">"section-link"</span>&gt;</span>#<span class="tag">&lt;/<span class="title">a</span>&gt;</span>我是章节标题<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span>我只是一个<span class="tag">&lt;<span class="title">em</span>&gt;</span>例子<span class="tag">&lt;/<span class="title">em</span>&gt;</span>。<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">article</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果我这么写 Sass 代码，是完全符合业务的嵌套关系的： <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.post</span> &#123;</span><br><span class="line">  <span class="tag">section</span> &#123;</span><br><span class="line">    <span class="class">.section-title</span> &#123;</span><br><span class="line">      <span class="attribute">color</span><span class="value">: <span class="hexcolor">#333</span>;</span></span><br><span class="line">      <span class="class">.section-link</span> &#123;</span><br><span class="line">        <span class="attribute">color</span><span class="value">: <span class="hexcolor">#999</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* other section styles */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* other post styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这样生成出来的选择器会有 <code>.post section .section-title .section-link</code>，很多时候我们觉得写成 <code>.post .section-link</code> 就够了。</p>
<p>于是我们在 Stylus 中可以这么写： <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.post</span></span><br><span class="line">  <span class="tag">section</span></span><br><span class="line">    <span class="class">.section-title</span></span><br><span class="line">      <span class="attribute">color</span> <span class="hexcolor">#333</span></span><br><span class="line">      /<span class="class">.post</span> <span class="class">.section-link</span></span><br><span class="line">        <span class="attribute">color</span> <span class="hexcolor">#999</span></span><br><span class="line">    <span class="comment">/* other section styles */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* other post styles */</span></span><br></pre></td></tr></table></figure></p>
<p>这样输出的 CSS 就会是： <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.post</span> <span class="tag">section</span> <span class="class">.section-title</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#333</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.post</span> <span class="class">.section-link</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#999</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这就是我们想要的样子了。当然也可以这样写：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.post</span></span><br><span class="line">  <span class="tag">section</span></span><br><span class="line">    <span class="class">.section-title</span></span><br><span class="line">      <span class="attribute">color</span> <span class="hexcolor">#333</span></span><br><span class="line">    <span class="comment">/* other section styles */</span></span><br><span class="line"></span><br><span class="line">  <span class="class">.section-link</span></span><br><span class="line">    <span class="attribute">color</span> <span class="hexcolor">#999</span></span><br><span class="line">  <span class="comment">/* other post styles */</span></span><br></pre></td></tr></table></figure>
<p>我个人是推荐这种写法（不使用 root 引用）的，因为当你确定 <code>.section-link</code> 的样式不依赖于它位于 <code>section</code> 或 <code>.section-title</code> 下时，就不应该嵌套于此。否则如果为了一点点<em>性能</em>上的考虑（还不一定会是优化），使得<em>设计意图</em>变得更不准确，我觉得得不偿失。</p>
<h2 id="变量">变量</h2>
<p>变量无疑为 CSS 增加了一种有效的复用方式，减少了原来在 CSS 中无法避免的重复「硬编码」。</p>
<p>Less：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@red:</span> <span class="hexcolor">#c00</span>;</span><br><span class="line"></span><br><span class="line"><span class="tag">strong</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@red</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sass：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$red</span><span class="value">: <span class="hexcolor">#c00</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">strong</span> &#123;</span><br><span class="line">  <span class="attribute">color</span><span class="value">: <span class="variable">$red</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stylus：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">red = <span class="hexcolor">#c00</span></span><br><span class="line"></span><br><span class="line"><span class="tag">strong</span></span><br><span class="line">  <span class="attribute">color</span>: red</span><br></pre></td></tr></table></figure>
<p>Less 的选择有一个问题：@ 规则在 CSS 中可以算是一种「原生」的扩展方式，变量名用 <code>@</code> 开头很可能会和以后的新 @ 规则冲突。（当然理论上只要 CSS 规范不引入 <code>@a: b</code> 这样的规则，问题也不大。而且规范制定的时候也会参考很多现有的实现。）</p>
<p>相比之下 Sass 的选择中规中矩，而 Stylus 就不同了，不需要额外的标志符。这意味着：在 Stylus 中，我们可以覆写 CSS 原生的属性值！Stylus 的设计让人有一种「你以为你在写 CSS，但其实你不是」的感觉，后面会有更多这样的例子。</p>
<p>顺便说一下，CSS 规范也有关于变量实现的草案，目前的方案是这个样子的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* global scope */</span></span><br><span class="line"><span class="pseudo">:root</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">--red</span>:<span class="value"> <span class="hexcolor">#c00</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">strong</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="function">var</span>(--red)</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>不管语法槽点如何，原生 CSS 变量可以通过 DOM 结构来继承，也就是说是代码真正「运行」时（runtime）决定的。元素引用一个变量时会按 DOM 向上查找定义在上层元素上的同名变量。这一点是任何预处理语言都无法做到的。可以用 Firefox 31+ 看一下<a href="http://jsbin.com/webuju/1/edit" target="_blank" rel="external">这个 demo</a>。至于这种机制是不是好用，暂时还没研究过。不过从开发的思维惯性来看，还很难一下子适应这种方式。</p>
<h3 id="变量作用域">变量作用域</h3>
<p>三种预处理器的变量作用域都是按嵌套的规则集划分，并且在当前规则集下找不到对应变量时会逐级向上查找，注意这个和原生 CSS 的逻辑是<em>完全不同</em>的。</p>
<p>如果我们在代码中重写某个已经定义的变量的值，Less 的处理逻辑和其他两者有非常<strong>关键</strong>的区别。在 Less 中，这个行为被称为「<a href="http://lesscss.org/features/#variables-feature-lazy-loading" target="_blank" rel="external">懒加载（Lazy Loading）</a>」。所有 Less 变量的计算，都是以这个变量最后一次被定义的值为准。举一个例子更容易说清楚：</p>
<p>Less：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@size:</span> <span class="number">10px</span>;</span><br><span class="line"><span class="class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">@size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@size:</span> <span class="number">20px</span>;</span><br><span class="line"><span class="class">.ball</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">@size</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.box</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">20px</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.ball</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">20px</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>而在 Stylus 中：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="number">10px</span></span><br><span class="line"><span class="class">.box</span></span><br><span class="line">  <span class="attribute">width</span>: size</span><br><span class="line"></span><br><span class="line">size = <span class="number">20px</span></span><br><span class="line"><span class="class">.ball</span></span><br><span class="line">  <span class="attribute">width</span>: size</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.box</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.ball</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">20px</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>Sass 的处理方式和 Stylus 相同，变量值输出时根据之前最近的一次定义计算。这其实代表了两种理念：Less 更倾向接近 CSS 的<em>声明式</em>，计算过程弱化调用时机；而 Sass 和 Stylus 更倾向于<em>指令式</em>。这两种方式会导致怎样的结果呢？</p>
<p>举个例子来说，对于 Less，如果项目中引入了这样一个文件：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@error-color:</span> <span class="hexcolor">#c00</span>;</span><br><span class="line"><span class="variable">@success-color:</span> <span class="hexcolor">#0c0</span>;</span><br><span class="line"><span class="class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@error-color</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="function">lighten</span>(<span class="variable">@error-color</span>, <span class="number">40%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class">.success</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@success-color</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="function">lighten</span>(<span class="variable">@success-color</span>, <span class="number">40%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在业务代码中，在不修改外部引入文件的情况下，如果我想重写这两种状态的配色，只需要重新配置 <code>@error-color</code> 和 <code>@success-color</code> 这两个变量，就能改变 <code>.error</code> 和 <code>.success</code> 的样式。</p>
<p>而在 Stylus 中，如果引入的第三方样式库中有这样的代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error-<span class="attribute">color</span> = <span class="hexcolor">#c00</span></span><br><span class="line">success-<span class="attribute">color</span> = <span class="hexcolor">#0c0</span></span><br><span class="line"></span><br><span class="line"><span class="class">.error</span></span><br><span class="line">  <span class="attribute">color</span>: error-<span class="attribute">color</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="function"><span class="title">lighten</span><span class="params">(error-color, <span class="number">40%</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="class">.success</span></span><br><span class="line">  <span class="attribute">color</span>: success-<span class="attribute">color</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="function"><span class="title">lighten</span><span class="params">(success-color, <span class="number">40%</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>这种情况下后面的代码就无法通过重写变量值来覆盖样式了。Sass 也是如此。优点是 Stylus 和 Sass 这样的处理会不容易受多个第三方库变量名冲突的影响，因为一个变量不能影响在定义它以前的输出样式。</p>
<p>由于 Sass 和 Stylus 变量在「运行」过程中使用完可以修改后再使用输出不同的值，所以这两者还提供了「仅当变量不存在时才赋值」的功能：</p>
<p>Sass：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$x</span><span class="value">: <span class="number">1</span>;</span></span><br><span class="line"><span class="variable">$x</span><span class="value">: <span class="number">5</span> !default;</span></span><br><span class="line"><span class="variable">$y</span><span class="value">: <span class="number">3</span> !default;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $x = 1, $y = 3</span></span><br></pre></td></tr></table></figure>
<p>Stylus：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">x := <span class="number">5</span> <span class="comment">// or x ?= 5</span></span><br><span class="line">y = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x = 1, y = 3</span></span><br></pre></td></tr></table></figure>
<p>因为变量只能在输出前修改才能生效，所以如果要定制第三方库的样式，用户代码理论上得插入第三方库的配置与样式之间才能生效。而有了 <code>!default</code>，第三方库在提供默认配置时可以将开发给用户修改的变量设置为 <code>!default</code>，这样只要用户提前引入配置进行覆盖，就可以按需重写默认配置了：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.scss</span></span><br><span class="line"><span class="variable">$alert-color</span><span class="value">: red !default;</span></span><br><span class="line"><span class="class">.alert</span> &#123;</span><br><span class="line">  <span class="attribute">color</span><span class="value">: <span class="variable">$alert-color</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var.scss</span></span><br><span class="line"><span class="variable">$alert-color</span><span class="value">: <span class="hexcolor">#c00</span>;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// page.scss</span></span><br><span class="line"><span class="at_rule">@<span class="keyword">import</span><span class="preprocessor"> var</span></span><br><span class="line">@<span class="keyword">import</span><span class="preprocessor"> lib</span></span></span><br></pre></td></tr></table></figure>
<p>这样最终页面输出的效果就是被用户重定义过的内容了。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* page.css */</span></span><br><span class="line"><span class="class">.alert</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#c00</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>由于 Less 处理变量的方式，如果我们要引入多个外部样式库或在多个团队进行合作开发时，如果不能确保开发过程可控，那为变量添加模块前缀就变得很有必要。</p>
<p>此外，Sass 中提供一个 <code>!global</code> 的语法来让局部变量变成全局变量，也就是说 Sass 代码可以在内层覆盖全局变量的值。输出一段局部的样式可能使得后续所有样式都受到全局变量变化的影响。（这其实是 Sass 开始时默认的逻辑，Sass 3.3 以前所有变量都是全局的，之后改成了和 Less 和 Stylus 一样有嵌套作用域，全局变量要显式指定 <code>!global</code>。）</p>
<h3 id="插值">插值</h3>
<p>预处理器都有定义变量的功能，除了在最常见的属性值中使用，其他还有哪些地方能用变量来增强对样式的抽象、复用呢？</p>
<h4 id="变量名插值">变量名插值</h4>
<p>Less 中支持 <code>@@foo</code> 的形式引用变量，即该变量的名字是由 <code>@foo</code> 的值决定的。比如我们可以利用它简化更清晰地调用 mixin：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some icon font lib</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// variables with prefix to prevent conflicts</span></span><br><span class="line"><span class="variable">@content-apple:</span> <span class="string">"A"</span>;</span><br><span class="line"><span class="variable">@content-google:</span> <span class="string">"G"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clearer argument values</span></span><br><span class="line"><span class="class">.icon-content</span>(<span class="variable">@icon</span>) &#123;</span><br><span class="line">  <span class="variable">@var:</span> <span class="string">~"content-@&#123;icon&#125;"</span>;</span><br><span class="line">  <span class="keyword">&amp;</span><span class="pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="variable">@@var</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.icon-apple</span> &#123;</span><br><span class="line">  <span class="class">.icon-content</span>(apple); <span class="comment">// "A"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.icon-google</span> &#123;</span><br><span class="line">  <span class="class">.icon-content</span>(google); <span class="comment">// "G"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择器插值">选择器插值</h4>
<p>选择器是样式表和 DOM 的纽带，是我们实际暴露给 HTML 的接口。支持插值显然可以让接口更不容易和其他内容冲突。假设我们在开发一个 UI 库，生成的组件类名希望有一个可配置的前缀，这时选择器插值就变得相当重要。初看下来，三者用法类似：</p>
<p>Less：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@prefix:</span> ui;</span><br><span class="line"><span class="class">.@&#123;prefix&#125;-button</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="hexcolor">#333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sass：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$prefix</span><span class="value">: ui</span><br><span class="line">.#&#123;<span class="variable">$prefix</span>&#125;-button</span><br><span class="line">  color: <span class="hexcolor">#333</span>;</span></span><br></pre></td></tr></table></figure>
<p>Stylus：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prefix = ui</span><br><span class="line">.&#123;prefix&#125;-button</span><br><span class="line">  color #333</span><br></pre></td></tr></table></figure>
<p>但是在 Less 中，有一个很严重的问题：通过选择器插值生成的规则无法被继承（<a href="https://github.com/less/less.js/issues/2200" target="_blank" rel="external">Extend dynamically generated selectors</a>）！当然，如果有类似 Placeholder 的机制，这都不是事儿了。问题是 Less 没有！未来的方案看来可能是通过 <code>:extend(.mixin())</code> 的方式实现类似功能（<a href="https://github.com/less/less.js/issues/1177" target="_blank" rel="external">:extend mixins</a>）。虽然用 <code>:extend</code> 本身的语法说不过去，但是在现有机制上来看还算可以接受。关于样式的继承复用，后面会详细讲到。</p>
<h4 id="import-语句插值"><span class="citation">@import</span> 语句插值</h4>
<p>Sass 中只能在使用 <code>url()</code> 表达式引入时进行变量插值：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$device</span><span class="value">: mobile;</span></span><br><span class="line"><span class="at_rule">@<span class="keyword">import</span><span class="preprocessor"> url</span>(styles.#&#123;</span><span class="variable">$device</span>&#125;<span class="class">.css</span>);</span><br></pre></td></tr></table></figure>
<p>Less 中可以在字符串中进行插值：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@device:</span> mobile;</span><br><span class="line"><span class="at_rule">@import</span> <span class="string">"styles.@&#123;device&#125;.css"</span>;</span><br></pre></td></tr></table></figure>
<p>Stylus 中在这里插值不管用，但是可以利用其字符串拼接的功能实现：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">device = <span class="string">"mobile"</span></span><br><span class="line"><span class="at_rule">@import</span> <span class="string">"styles."</span> + device + <span class="string">".css"</span></span><br></pre></td></tr></table></figure>
<p>注意由于 Less 的 Lazy Load 特性，即使是 <code>@import</code> 也是可以在后面的文件内容中进行覆盖的，修改掉变量就可以在前面引入不同的外部文件。而 Sass 与 Stylus 一旦输出语句，就无法通过变量改变了。</p>
<h4 id="属性名插值">属性名插值</h4>
<p>三个预处理器的目前版本都支持属性名插值，用法也类似。这里仅以 Stylus 为例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">red-border(sides)</span><br><span class="line">  for side in sides</span><br><span class="line">    border-&#123;side&#125;-color: red // property name interpolation</span><br><span class="line"></span><br><span class="line">.x</span><br><span class="line">  red-border(top right)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.x</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">border-top-color</span>:<span class="value"> <span class="hexcolor">#f00</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">border-right-color</span>:<span class="value"> <span class="hexcolor">#f00</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="其他-规则插值">其他 <code>@</code> 规则插值</h4>
<p>三种预处理器均支持在 <code>@media</code>、<code>@keyframes</code>、<code>@counter-style</code> 等规则中进行插值。<code>@media</code> 插值主要用来做响应式的配置，而 <code>@keyframes</code> 这样带名称名称的 <code>@</code> 规则则可以通过插值来避免命名冲突。</p>
<p>Less：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@m:</span> screen;</span><br><span class="line"><span class="variable">@orient:</span> landscape;</span><br><span class="line"><span class="at_rule">@media</span> <span class="variable">@m</span> and (<span class="attribute">orientation</span>: <span class="variable">@orient</span>) &#123;</span><br><span class="line">  <span class="tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">960px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@prefix:</span> ui;</span><br><span class="line"><span class="at_rule">@keyframes</span> <span class="string">~"@&#123;prefix&#125;-fade-in"</span> &#123;</span><br><span class="line">  <span class="tag">0%</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="tag">100%</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sass：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$m</span><span class="value">: screen;</span></span><br><span class="line"><span class="variable">$orient</span><span class="value">: landscape;</span></span><br><span class="line"><span class="at_rule">@<span class="keyword">media</span> #&#123;</span><span class="variable">$m</span>&#125; and (orientation<span class="value">: <span class="variable">$orient</span>) &#123;</span><br><span class="line">  body &#123;</span><br><span class="line">    width: <span class="number">1000px</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$prefix</span><span class="value">: ui;</span></span><br><span class="line"><span class="at_rule">@keyframes #&#123;</span><span class="variable">$prefix</span>&#125;-fade-in &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">opacity</span><span class="value">: <span class="number">0</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">opacity</span><span class="value">: <span class="number">1</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stylus：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">m = screen</span><br><span class="line">orient = landscape</span><br><span class="line">mq = m + " and (orientation: " + orient + ")"</span><br><span class="line">@media mq</span><br><span class="line">  body</span><br><span class="line">    width: 960px</span><br><span class="line"></span><br><span class="line">vendors = official</span><br><span class="line">prefix = ui;</span><br><span class="line">@keyframes &#123;prefix&#125;-fade-in &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    opacity: 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三者均会输出如下 CSS：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">media</span> screen and (orientation: landscape) </span>&#123;</span><br><span class="line">  <span class="tag">body</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">960px</span></span></span>;</span><br><span class="line">  <span class="rule">&#125;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="at_rule">@<span class="keyword">keyframes</span> ui-fade-in </span>&#123;</span><br><span class="line">  0% <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">opacity</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">  <span class="rule">&#125;</span></span></span><br><span class="line">  100% <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">opacity</span>:<span class="value"> <span class="number">1</span></span></span>;</span><br><span class="line">  <span class="rule">&#125;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stylus 中似乎有 <code>and</code> 时由于表达式计算的逻辑不能直接像 Less 与 Sass 那样写插值，所以这里采用了字符串拼接的方式。</p>
<h2 id="import"><code>@import</code></h2>
<p><code>@import</code> 对于模块化开发来说非常有帮助，但就这个功能来说，三种预处理器的行为各不相同。</p>
<p>先说 Less，Less 扩展了语法，为 <code>@import</code> 增加了多种选项：</p>
<ol style="list-style-type: decimal">
<li><code>@import (less) somefile.ext</code></li>
</ol>
<p>会将无论什么扩展名的文件都作为 Less 文件引入、一起编译；</p>
<ol start="2" style="list-style-type: decimal">
<li><code>@import (css) somefile.ext</code></li>
</ol>
<p>直接编译生成 <code>@import somefile.ext</code>，当做原生 <code>@import</code>；</p>
<ol start="3" style="list-style-type: decimal">
<li><code>@import (inline) somefile.ext</code></li>
</ol>
<p>直接将外部文件拷贝进输出文件的这个位置，但不会参与编译；</p>
<ol start="4" style="list-style-type: decimal">
<li><code>@import (reference) somefile.ext</code></li>
</ol>
<p>外部文件参与编译，但不输出内容，仅用来被本文件中的样式继承；</p>
<ol start="5" style="list-style-type: decimal">
<li><code>@import (optional) somefile.ext</code></li>
</ol>
<p>引入文件但在文件不存在时不报错，静默失败。</p>
<p>上面的选项是可以联合使用的，比如可以这样写：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@import</span> (less, optional) somefile.ext;</span><br></pre></td></tr></table></figure>
<p>除此之外还有 <code>once</code> 和 <code>multiple</code> 选项分别用来表示去重和不去重的引入方式，默认为 <code>once</code>。在不写任何选项时，Less 会根据扩展名进行推断来决定引入逻辑。</p>
<p>Sass 没有扩展语法，而是自己推断引入的方式。<code>.css</code> 后缀、绝对路径、<code>url()</code> 表达式和带有 media query 的 <code>@import</code> 会直接用原生 <code>@import</code>，其他都会作为 Sass 代码参与编译。相比之下 Less 更灵活也更复杂。Sass 有个特有的功能叫做「partial」，因为 Sass 默认的编译工具可以编译整个目录下的文件，所以当一些文件不需要编译时，可以在文件名前加上 <code>_</code> 表明这是一个被别的模块引入本身不需要编译的代码片段。Less 的 <code>lessc</code> 由于本来就只处理一个文件，所以这件事就交给用户自己去写编译脚本了。Sass 中有一个比较棘手的问题是，<code>@import</code> 不会被去重，多次引入会导致一个样式文件被多次输出到编译结果中。为了解决这个问题，Foundation 做了如下的 <a href="https://github.com/zurb/foundation/blob/a1eb7561ef835313e20995488afb3f627b27354a/scss/foundation/_functions.scss#L8-L21" target="_blank" rel="external">hack</a>：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMPORT ONCE</span></span><br><span class="line"><span class="comment">// We use this to prevent styles from being loaded multiple times for components that rely on other components.</span></span><br><span class="line"><span class="variable">$modules</span><span class="value">: () !default;</span></span><br><span class="line"></span><br><span class="line"><span class="at_rule">@<span class="keyword">mixin</span><span class="preprocessor"> exports</span>(<span class="variable">$name</span>) &#123;</span></span><br><span class="line">  <span class="comment">// Import from global scope</span></span><br><span class="line">  <span class="variable">$modules</span><span class="value">: <span class="variable">$modules</span> !global;</span></span><br><span class="line">  <span class="comment">// Check if a module is already on the list</span></span><br><span class="line">  <span class="variable">$module_index</span><span class="value">: <span class="function">index</span>(<span class="variable">$modules</span>, <span class="variable">$name</span>);</span></span><br><span class="line">  <span class="at_rule">@<span class="keyword">if</span> ((<span class="variable">$module_index</span> ==<span class="preprocessor"> null</span>)<span class="preprocessor"> or</span> (<span class="variable">$module_index</span> ==<span class="preprocessor"> false</span>)) &#123;</span></span><br><span class="line">    <span class="variable">$modules</span><span class="value">: <span class="function">append</span>(<span class="variable">$modules</span>, <span class="variable">$name</span>) !global;</span></span><br><span class="line">    <span class="at_rule">@<span class="keyword">content</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在定义样式时都调用 <code>exports</code> 这个 mixin 来输出，起到只输出一次的效果。</p>
<p>Stylus 和 Sass 比较接近，也使用隐性推断的方式，但在处理重复输出的问题上，Stylus 给出了一个自定义指令 <code>@require</code>，用法和 <code>@import</code> 完全一样，但只会输出一次。Stylus 还支持通配符，比如 <code>@import 'product/*'</code> 会引入 <code>product</code> 目录下的所有 <code>.styl</code> 文件，但因为一般引入样式都要显式指定顺序，所以这个功能实用性不高。</p>
<p>三者相比较之下，Sass 的引入功能似乎有点残缺，不能去重是很大的硬伤。虽然能用 Foundation 那种方式「解决」，但实际上这是语言本身应该解决的问题。</p>
<h2 id="混入">混入</h2>
<p>混入（mixin）应该说是预处理器最精髓的功能之一了。它提供了 CSS 缺失的最关键的东西：样式层面的抽象。从语法上来说，三种预处理器的差异也比较大，这甚至会直接影响到我们的开发方式。</p>
<p>Less 的混入有两种方式：</p>
<ol style="list-style-type: decimal">
<li>直接在目标位置混入另一个类样式（输出已经确定，无法使用参数）；</li>
<li>定义一个不输出的样式片段（可以输入参数），在目标位置输出。（<strong>注：后面如无特殊说明，mixin 均用来指代此类混入。</strong>）</li>
</ol>
<p>举例来说：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.alert</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.highlight</span>(<span class="variable">@color</span>: red) &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.heads-up</span> &#123;</span><br><span class="line">  <span class="class">.alert</span>;</span><br><span class="line">  <span class="class">.highlight</span>(red);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.alert</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> <span class="number">700</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.heads-up</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> <span class="number">700</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">1.2em</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>可以混入已有类样式这一点很值得商榷。在上面的例子中，<code>.alert</code> 样式在被混入时甚至可以是 <code>.alert();</code>；<code>.highlight()</code> 混入时也可以写成 <code>.highlight;</code>。那么我们遇到这样的代码时根本不知道 <code>alert</code> 会不会是一个 HTML class。但由于这一点是在 Less 还不支持 extend 时就有的，所以也能够理解作者可能就是将这作为 extend 来用了。所以目前比较好的实践是：用代码规范规约开发者不得使用直接混入已有类样式的方式，而是先定义 mixin 然后在输出的类样式中进行调用，调用时必须显式加上 <code>()</code> 来表明这不是一个 class（事实上百度 EFE 已有的 <a href="https://github.com/ecomfe/spec/blob/master/less-code-style.md#user-content-混入mixin-1" target="_blank" rel="external">Less 编码规范</a>就是这么定义的）。继承则应该直接通过 Less 的 <code>:extend</code> 来实现。</p>
<p>另外需要注意的是，Less 在进行混入时，会找到所有符合调用参数的「mixin 签名」的样式一起输出。比如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.mixin</span>(dark; <span class="variable">@color</span>) &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="function">darken</span>(<span class="variable">@color</span>, <span class="number">10%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class">.mixin</span>(light; <span class="variable">@color</span>) &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="function">lighten</span>(<span class="variable">@color</span>, <span class="number">10%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class">.mixin</span>(<span class="variable">@_</span>; <span class="variable">@color</span>) &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@switch:</span> light;</span><br><span class="line"><span class="class">.class</span> &#123;</span><br><span class="line">  <span class="class">.mixin</span>(<span class="variable">@switch</span>; <span class="hexcolor">#888</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中，第二个和第三个 mixin 都匹配了调用时的参数，于是它们的规则都会被输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.class</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#a2a2a2</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>也就是说同名的 mixin 不是后面覆盖前面，而是会累加输出。只要参数符合定义，就会将 mixin 内部的<em>样式规则</em>、甚至<em>变量</em>全部拷贝到目标作用域下。</p>
<p>这一点同样会带来一个问题：如果存在和 mixin 同名的 class 样式，如果 mixin 没有参数则在调用时会把对应的 class 样式一起输出，这显然是不符合预期的。</p>
<p>假设有个叫 <code>.clearfix</code> 的 mixin，有两个 class 样式调用了它（其中一个也叫 clearfix）：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.clearfix</span>() &#123;</span><br><span class="line">  *<span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">&amp;</span><span class="pseudo">:before</span>,</span><br><span class="line">  <span class="keyword">&amp;</span><span class="pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.clearfix</span> &#123;</span><br><span class="line">  <span class="class">.clearfix</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.list</span> &#123;</span><br><span class="line">  <span class="class">.clearfix</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到的输出是：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.clearfix</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule">*<span class="attribute">zoom</span>:<span class="value"> <span class="number">1</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.clearfix</span><span class="pseudo">:before</span>,</span><br><span class="line"><span class="class">.clearfix</span><span class="pseudo">:after</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">display</span>:<span class="value"> table</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">""</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.clearfix</span><span class="pseudo">:after</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">clear</span>:<span class="value"> both</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.list</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule">*<span class="attribute">zoom</span>:<span class="value"> <span class="number">1</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.list</span><span class="pseudo">:before</span>,</span><br><span class="line"><span class="class">.list</span><span class="pseudo">:after</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">display</span>:<span class="value"> table</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">""</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.list</span><span class="pseudo">:after</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">clear</span>:<span class="value"> both</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.list</span><span class="pseudo">:before</span>,</span><br><span class="line"><span class="class">.list</span><span class="pseudo">:after</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">display</span>:<span class="value"> table</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">""</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.list</span><span class="pseudo">:after</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">clear</span>:<span class="value"> both</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><code>.list</code> 的样式调用了两次！这一点在开发中一定要注意，不要给和非输出型 mixin 同名的类定义样式。</p>
<p>对于 Sass，语义非常明确：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">mixin</span><span class="preprocessor"> large-text</span> &#123;</span></span><br><span class="line">  <span class="attribute">font</span><span class="value">: &#123;</span><br><span class="line">    family: Arial;</span></span><br><span class="line">    size<span class="value">: <span class="number">20px</span>;</span></span><br><span class="line">    weight<span class="value">: bold;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attribute">color</span><span class="value">: <span class="hexcolor">#ff0000</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.page-title</span> &#123;</span><br><span class="line">  <span class="at_rule">@<span class="keyword">include</span><span class="preprocessor"> large-text</span>;</span></span><br><span class="line">  <span class="attribute">padding</span><span class="value">: <span class="number">4px</span>;</span></span><br><span class="line">  <span class="attribute">margin-top</span><span class="value">: <span class="number">10px</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sass 用 <code>@mixin</code> 和 <code>@include</code> 两个指令清楚地描述了语义，不存在混入类样式的情况，但是书写时略显繁琐一些。当然，用 Sass 语法 而非 SCSS 语法的话可以简单地用 <code>=</code> 定义 mixin，用 <code>+</code> 引入 mixin：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=large-text&#10;  font:&#10;    family: Arial&#10;    size: 20px&#10;    weight: bold&#10;  color: #ff0000&#10;&#10;.page-title&#10;  +large-text&#10;  padding: 4px&#10;  margin-top: 10px</span><br></pre></td></tr></table></figure>
<p>和 Less 不同，同名的 mixin 可以覆盖之前的定义，作用机制类似变量。</p>
<p>Stylus 和 Sass 类似，但不用什么特殊的标记来引入：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">border-radius</span><span class="params">(n)</span></span></span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: n</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: n</span><br><span class="line">  <span class="attribute">border-radius</span>: n</span><br><span class="line"></span><br><span class="line"><span class="class">.circle</span></span><br><span class="line">  <span class="function"><span class="title">border-radius</span><span class="params">(<span class="number">50%</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>Stylus 中还有一个「透明 mixin」的功能，也就是说引入 mixin 完全可以和引入普通属性一样！例如上面的这个 mixin，也可以这样引入：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.circle</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span></span><br></pre></td></tr></table></figure>
<p>这意味着可以把兼容性上的处理隐藏在 mixin 中，直接用标准属性同名的 mixin 按普通属性的方式输出。当不需要兼容老浏览器时，直接把 mixin 定义删除仍然能够正常输出。不过这种写法虽然感觉非常「爽快」，但要求开发者必须能很好地区分原生属性和某个样式库中提供的 mixin 功能（对于有经验的开发者问题不大），而且透明意味着看到一个普通属性开发者不能判断是否已经在某处用 mixin 进行了重写，无法明确知道这里的代码最后输出会不会发生变化。在可控条件下，这个功能应该说是非常诱人的。</p>
<h3 id="将声明块作为混入参数">将声明块作为混入参数</h3>
<p>如果说调用时想传入一组样式声明而非单个值，三种预处理器都提供了相应的功能，但实现方式各有不同。</p>
<p>在 Less 中需要先定义一个「规则集变量」（detached ruleset，其实就是 CSS 声明块，即规则集去掉选择器的部分），然后在调用 mixin 时把它作为参数传进去，然后在 mixin 中用 <code>@var()</code> 的方式输出：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.red</span>(<span class="variable">@custom</span>) &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="variable">@custom</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.alert</span> &#123;</span><br><span class="line">  <span class="variable">@styles:</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .<span class="function">red</span>(<span class="variable">@styles</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Sass 和 Stylus 中，都支持直接在 mixin 调用下层传入声明块：</p>
<p>Sass 下直接跟一个声明块即可，然后用关键字 <code>@content</code> 来进行输出：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">mixin</span><span class="preprocessor"> red</span>() &#123;</span></span><br><span class="line">  <span class="attribute">color</span><span class="value">: red;</span></span><br><span class="line">  <span class="at_rule">@<span class="keyword">content</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.alert</span> &#123;</span><br><span class="line">  <span class="at_rule">@<span class="keyword">include</span><span class="preprocessor"> red</span>() &#123;</span></span><br><span class="line">    <span class="attribute">font-weight</span><span class="value">: <span class="number">700</span>;</span></span><br><span class="line">    <span class="attribute">font-size</span><span class="value">: <span class="number">1.5em</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stylus 支持两种方法，首先是 Less 那样的「具名」声明块，调用时当做变量：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">red(foo)</span><br><span class="line">  color: red</span><br><span class="line">  &#123;foo&#125;</span><br><span class="line"></span><br><span class="line">.alert</span><br><span class="line">  foo =</span><br><span class="line">    font-weight: 700</span><br><span class="line">    font-size: 1.5em</span><br><span class="line">  red(foo)</span><br></pre></td></tr></table></figure>
<p>第二种是 Sass 那样类似传入「字面量」，并且用关键词 <code>block</code> 输出的方式。这种方式需要为要传入声明块的 mixin 前添加一个 <code>+</code> 符号（可能是来自 SCSS 的对应功能）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">red()</span><br><span class="line">  color: red</span><br><span class="line">  &#123;block&#125;</span><br><span class="line"></span><br><span class="line">.alert</span><br><span class="line">  +red()</span><br><span class="line">    font-weight: 700</span><br><span class="line">    font-size: 1.5em</span><br></pre></td></tr></table></figure>
<p>第二种方式可以看做是第一种方式的语法糖，在 mixin 只需要传入一个声明块时可以免去起名字带来的困扰。</p>
<p>相比之下 Less 只支持先定义变量后传入的方式，优点是可以传入多个声明块；而 Sass 只支持传入一个「匿名」声明块但是更简单；Stylus 则是两种方式都支持。这个功能在抽象「需要应用样式的条件」时非常有用，比如我们基于 Stylus 的样式库 <a href="https://github.com/ecomfe/rider" target="_blank" rel="external">rider</a> 中就用它来实现<a href="https://github.com/ecomfe/rider/blob/master/lib/rider/breakpoint.styl" target="_blank" rel="external">对 media query 的抽象封装</a>。</p>
<h2 id="继承">继承</h2>
<p>混入很好用，可也有问题：如果多个地方都混入同样的代码，会造成输出代码的多次重复。比如在 Stylus 下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">message</span><span class="params">()</span></span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span></span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="hexcolor">#eee</span></span><br><span class="line"></span><br><span class="line"><span class="class">.message</span></span><br><span class="line">  <span class="function"><span class="title">message</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="class">.warning</span></span><br><span class="line">  <span class="function"><span class="title">message</span><span class="params">()</span></span></span><br><span class="line">  <span class="attribute">color</span>: <span class="hexcolor">#e2e21e</span></span><br></pre></td></tr></table></figure>
<p>会输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.message</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#eee</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.warning</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#eee</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#e2e21e</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>而我们可能期望的输出是：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.message</span>,</span><br><span class="line"><span class="class">.warning</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#eee</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.warning</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#e2e21e</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>也许大家会说可以这么写：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">message</span><span class="params">()</span></span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span></span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="hexcolor">#eee</span></span><br><span class="line"></span><br><span class="line"><span class="class">.message</span>,</span><br><span class="line"><span class="class">.warning</span></span><br><span class="line">  <span class="function"><span class="title">message</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="class">.warning</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="hexcolor">#e2e21e</span></span><br></pre></td></tr></table></figure>
<p>这样就可以按需要输出了。但其实预处理器的一个好处就是可以方便我们进行模块化开发。上面的例子中，<code>.message</code> 和 <code>.warning</code> 的样式如果是分布在两个模块中的，我合并过的选择器组样式写在哪里呢？情况更复杂的时候就更棘手了。</p>
<p>这个时候就该继承出场了：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.message</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span></span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="hexcolor">#eee</span></span><br><span class="line"></span><br><span class="line"><span class="class">.warning</span></span><br><span class="line">  <span class="at_rule">@extend</span> <span class="class">.message</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="hexcolor">#e2e21e</span></span><br></pre></td></tr></table></figure>
<p>这样就可以按模块进行开发（不管是分文件还是在同一文件中按业务功能安排样式的顺序），同时兼顾输出的效率了。</p>
<p>Stylus 的继承方式来自 Sass，两者如出一辙。 而 Less 则又「独树一帜」地用<strong>伪类</strong>来描述继承关系：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.message</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="hexcolor">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.warning</span> &#123;</span><br><span class="line">  <span class="keyword">&amp;</span><span class="keyword">:extend</span>(<span class="class">.message</span>);</span><br><span class="line">  <span class="attribute">color</span>: <span class="hexcolor">#e2e21e</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Or:</span><br><span class="line">.warning:extend(.message) &#123;</span><br><span class="line">  color: #e2e21e;</span><br><span class="line">&#125;</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>同时，Less 默认只继承父类本身的样式，如果要同时继承嵌套定义在父类作用域下的样式，得使用关键字 <code>all</code>，比如 <code>&amp;:extend(.message all);</code>。</p>
<p>关于使用伪类描述继承关系，<a href="http://weibo.com/u/1960954893" target="_blank" rel="external">Hax</a> 在 Less 的另一个 issue 下曾经<a href="https://github.com/less/less.js/issues/1177#issuecomment-17404003" target="_blank" rel="external">言辞激烈地提出了批评</a>，同时也遭到了 Less 项目组毫不客气的回应。我个人完全赞同 Hax 的看法，因为选择器是用来在树结构中找到元素的，和样式本身完全无关。但 Less 社区在当时却对<a href="https://github.com/less/less.js/pull/509#issuecomment-9963343" target="_blank" rel="external">这个语法</a>表示了一致的赞同，不禁让人对其感到担忧。</p>
<p>不管语法如何，继承功能还有一个潜在的问题：继承会影响输出的顺序。假设有如下的 Sass 代码：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.active</span> &#123;</span><br><span class="line">   <span class="attribute">color</span><span class="value">: red;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">button</span><span class="class">.primary</span> &#123;</span><br><span class="line">   <span class="attribute">color</span><span class="value">: green;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">button</span><span class="class">.active</span> &#123;</span><br><span class="line">   <span class="at_rule">@<span class="keyword">extend</span><span class="preprocessor"> .active</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对应的 HTML 代码是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">button</span> <span class="attribute">class</span>=<span class="value">"primary active"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>很容易误以为效果是红色的。而其实生成的 CSS 顺序如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.active</span>, <span class="tag">button</span><span class="class">.active</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">button</span><span class="class">.primary</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value"> green</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>由于合并选择器的关系 <code>.active</code> 被移到了 <code>.primary</code> 之前，所以依赖顺序而非选择器 specificity 时可能会遇到陷阱。</p>
<h3 id="placeholder">placeholder</h3>
<p>Placeholder 是什么？简单来说就是一个声明块（预处理器 DSL 中的声明块，包含其下嵌套规则），但是不会在最终的 CSS 中输出。其实这是一组「抽象」样式，只存在于预处理器的编译过程中（类似 mixin），但不同之处是它可以被继承。这样我们就可以在纯样式层为声明块起与样式强耦合的名称而不怕它出现在 CSS 与 HTML 的「接口」——选择器之中了。</p>
<p>Sass：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%red-card &#123;</span><br><span class="line">  <span class="attribute">border</span><span class="value">: <span class="number">1px</span> solid <span class="hexcolor">#300</span>;</span></span><br><span class="line">  <span class="attribute">background-color</span><span class="value">: <span class="hexcolor">#ecc</span>;</span></span><br><span class="line">  <span class="attribute">color</span><span class="value">: <span class="hexcolor">#c00</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.alert</span> &#123;</span><br><span class="line">  <span class="at_rule">@<span class="keyword">extend</span> %red-card;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stylus：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$red</span>-card</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="hexcolor">#300</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="hexcolor">#ecc</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="hexcolor">#c00</span></span><br><span class="line"></span><br><span class="line"><span class="class">.alert</span></span><br><span class="line">  <span class="at_rule">@extend</span> <span class="variable">$red</span>-card</span><br></pre></td></tr></table></figure>
<p>均输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.alert</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#300</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#ecc</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#c00</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>Less 目前不支持这个功能，但开发组目前的共识是可能会用<a href="https://github.com/less/less.js/issues/1177" target="_blank" rel="external">继承 mixin</a> 的方式来实现，比如上面的这个例子未来可能可以通过如下方法实现：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.red-card</span>() &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="hexcolor">#300</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="hexcolor">#ecc</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="hexcolor">#c00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.alert</span> &#123;</span><br><span class="line">  <span class="keyword">&amp;</span><span class="keyword">:extend</span>(<span class="class">.red-card</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前在 Less 下也有一个 hack 来模拟 placeholder 功能，原理是利用 <code>@import (reference)</code> 来实现「placeholder」不输出的功能：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// placeholder.less</span></span><br><span class="line"><span class="class">.red-card</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="hexcolor">#300</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="hexcolor">#ecc</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="hexcolor">#c00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// style.less</span></span><br><span class="line"><span class="at_rule">@import</span> (reference) <span class="string">"placeholder.less"</span>;</span><br><span class="line"><span class="class">.alert</span> &#123;</span><br><span class="line">  <span class="keyword">&amp;</span><span class="keyword">:extend</span>(<span class="class">.red-card</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过 <code>@import (reference)</code> 在复杂一些的情况下（被引入的文件有 <code>@import</code>、有 <code>:extend</code> 等）可能会遇到一些 bug，比如：<a href="https://github.com/less/less.js/issues/1851" target="_blank" rel="external">#1851</a>、<a href="https://github.com/less/less.js/issues/1878" target="_blank" rel="external">#1878</a>、<a href="https://github.com/less/less.js/issues/1896" target="_blank" rel="external">#1896</a>。目前以 reference 方式引入 Bootstrap 时就会直接产生代码输出。</p>
<h2 id="函数">函数</h2>
<p>先说说原生函数。三种预处理器都自带了诸如色彩处理、类型判断、数值计算等内置函数，目前版本的数量都在 80 个左右。由于 Sass 和 Stylus 都内置脚本语言，所以自带函数中包括了很多处理不同数据类型、修改选择器的函数。Sass 更是提供了不少特性检测函数比如 <a href="http://sass-lang.com/documentation/Sass/Script/Functions.html#feature_exists-instance_method" target="_blank" rel="external">feature-exists($feature)</a>、<a href="http://sass-lang.com/documentation/Sass/Script/Functions.html#variable_exists-instance_method" target="_blank" rel="external">variable-exists($name)</a> 等，这为第三方库的兼容性提供了很好的保障。因为有了这些函数可以方便地对不同版本的 Sass 编译器有针对性地提供兼容，而不怕在老版本的编译环境中直接报错。</p>
<p>三者调用函数的方式几乎一致，不同之处在于 Sass 和 Stylus 支持直接指定参数名的方式传入参数。以 Stylus 为例：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">subtract</span><span class="params">(a, b)</span></span></span><br><span class="line">  <span class="tag">a</span> - <span class="tag">b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">subtract</span><span class="params">(b: <span class="number">10</span>, a: <span class="number">25</span>)</span></span> <span class="comment">// same as substract(25, 10)</span></span><br></pre></td></tr></table></figure>
<p>这样做的好处是，如果参数列表比较长，Stylus 可以直接为列表后面的参数赋值，而不需要一路将之前的参数填上 <code>null</code> 或默认值。Stylus 将这个特性称为「Named parameters」，而 Sass 称为「Keyword arguments」。</p>
<p>关于函数，真正的区别在于：Sass 和 Stylus 都支持用 DSL 直接添加自定义函数，而 Less 中如果要添加自定义函数必须通过使用插件（2.0.0 以后的版本才支持插件）。这决定了用 Sass 和 Stylus 书写的代码可移植性更高，不需要编译环境有插件即可运行，而 Less 则需要额外添加编译时的依赖。</p>
<p>Sass 中自定义函数需要使用 <code>@function</code> 指令，并用 <code>@return</code> 指令返回结果：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@function<span class="preprocessor"> golden-ratio</span>(<span class="variable">$n</span>) &#123;</span></span><br><span class="line">  <span class="at_rule">@return <span class="variable">$n</span> *<span class="preprocessor"> 0.618</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class">.golden-box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span><span class="value">: <span class="number">200px</span>;</span></span><br><span class="line">  <span class="attribute">height</span><span class="value">: <span class="function">golden-ratio</span>(<span class="number">200px</span>);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Stylus 中，这些都是隐含的，最后一个表达式的值会作为返回值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">golden-ratio(n)</span><br><span class="line">  n * 0.618</span><br><span class="line"></span><br><span class="line">.golden-box</span><br><span class="line">  width: 200px</span><br><span class="line">  height: golden-ratio(@width)</span><br></pre></td></tr></table></figure>
<p>这种写法和 mixin 有什么区别？当把函数作为 mixin 调用时，如果其中有 <code>prop: value</code> 这样格式的内容，就会被当做样式规则输出。Stylus 中大量的内容都是根据调用时的 context 去隐式推断该使用什么逻辑进行输出，而非 Less 和 Sass 那样使用关键字去显式地进行区分。</p>
<h2 id="逻辑控制">逻辑控制</h2>
<p>Sass 中通过常见的 <code>@if</code>、<code>@else if</code>、<code>@else</code> 实现条件分支，通过 <code>@for</code>、<code>@each</code>、<code>@while</code> 实现循环，配合 map 和 list 这两种数据类型可以轻松地实现多数编程语言提供的功能。</p>
<p>在 Stylus 中，不需要使用 @ 规则，提供了 <code>if</code>、<code>else if</code>、<code>else</code>、<code>unless</code>、<code>for...in</code> 来实现类似功能，语法比 Sass 更简洁灵活。</p>
<p>再来看 Less，上面说到的功能 Less 都没有提供。那在 Less 中如何进行逻辑控制呢？Less 中只有一个方式：使用 mixin。</p>
<p>Less 中的 mixin 通过「guard」的方式支持简单的条件分支控制。比如我们要实现一个控制 <code>::placeholder</code> 样式的 mixin，当传入颜色时只设置颜色，当传入声明块时输出对应的样式规则，其他情况输出一个默认的 <code>color</code>：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.mixin</span>(<span class="variable">@val</span>) <span class="keyword">when</span> (<span class="function">iscolor</span>(<span class="variable">@val</span>)) &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@val</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class">.mixin</span>(<span class="variable">@val</span>) <span class="keyword">when</span> (<span class="function">isruleset</span>(<span class="variable">@val</span>)) &#123;</span><br><span class="line">  <span class="variable">@val</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class">.mixin</span>(<span class="variable">@val</span>) <span class="keyword">when</span> (<span class="function">default</span>()) &#123;</span><br><span class="line">  <span class="comment">// default() in guards acts as else</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="hexcolor">#666</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Guard 语句中的语法非常类似 CSS media query 中的对应功能，事实上这也是 Less 一直以来的理念：保持声明式语法，弱化指令和流程。但是事实上，这为书写需要提供灵活接口的样式库造成了非常大的不便。最简单的三元表达式在 Less 中也需要先定义一个 mixin，根据判断条件写对应的 guard 表达式，然后再输出。</p>
<p>而对于循环，Less 本身并不支持。但官网给出了一个使用 mixin 递归调用模拟循环的例子：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.loop</span>(<span class="variable">@counter</span>) <span class="keyword">when</span> (<span class="variable">@counter</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="class">.loop</span>((<span class="variable">@counter</span> - <span class="number">1</span>));    <span class="comment">// next iteration</span></span><br><span class="line">  <span class="attribute">width</span>: (<span class="number">10px</span> * <span class="variable">@counter</span>); <span class="comment">// code for each iteration</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">div</span> &#123;</span><br><span class="line">  <span class="class">.loop</span>(<span class="number">5</span>); <span class="comment">// launch the loop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译结果为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">20px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">30px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">40px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">50px</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>这是一种非常别（dàn）扭（téng）的实现方式，但从 Less 开发团队的态度来看，未来并没什么可能在 Less 中见到真正的条件分支和循环——因为「Less 不是 Sass」。</p>
<p>由于逻辑处理能力不能与 Sass 和 Stylus 相比，所以在 Less 中可能还会需要借助 JS 表达式来进行 mixin 参数的解析处理。这个功能 Less 官方已经是不推荐使用的了（已经从官网文档中移除）——因为使用这一功能也会导致 Less 代码的可移植性变低，因为直接内嵌 JS 代码，所以无法使用 <a href="http://www.dotlesscss.org/" target="_blank" rel="external">dotless</a> 等其他语言的 Less 编译器进行处理。而且不同 JS 引擎还可能有兼容性差异。</p>
<h2 id="总结">总结</h2>
<p>我个人认为，Less 从语言特性的设计到功能的健壮程度和另外两者相比都有一些缺陷，但因为 Bootstrap 引入了 Less，导致 Less 在今天还是有很多用户。用 Less 可以满足大多数场景的需求，但相比另外两者，基于 Less 开发类库会复杂得多，实现的代码会比较脏，能实现的功能也会受到 DSL 的制约。比 Stylus 语义更清晰、比 Sass 更接近 CSS 语法，使得刚刚转用 CSS 预编译的开发者能够更平滑地进行切换。当初 Sass 并不支持 SCSS 语法，使得转投 Sass 成本较高，所以 <a href="http://cloudhead.io/" target="_blank" rel="external">Alexis Sellier</a> 才萌生开发一个更「CSS」的预处理器的念头。大获成功以后反过来影响到了 Sass，迫使其也支持类似 CSS 语法的 SCSS。另外，Less 支持浏览器端编译，这无疑降低了开发门槛，使得很多非专业的开发者能够更快地上手（对于一些个人项目来说，能让项目跑起来就行，对前端的性能并没有专业工程师那么高的要求）。</p>
<p>Sass 在三者之中历史最久，也吸收了其他两者的一些优点。从功能上来说 Sass 大而全，语义明晰但是代码很容易显得累赘。主项目基于 Ruby 可能也是一部分人不选择它的理由（Less 开始也是基于 Ruby 开发，后来逐渐转到 <a href="https://github.com/less/less.js" target="_blank" rel="external">less.js</a> 项目中）。 Sass 有一个「事实标准」库——<a href="http://compass-style.org/" target="_blank" rel="external">Compass</a>，于是对于很多开发者而言省去了选择类库的烦恼，对于提升开发效率也有不小的帮助。</p>
<p>Stylus 的语法非常灵活，很多语义都是根据上下文隐含的。基于 Stylus 可以写出非常简洁的代码，但对使用团队的开发素养要求也更高，更需要有良好的开发规范或约定。Stylus 是前 Node.js 圈第一大神 <a href="https://github.com/tj/" target="_blank" rel="external">TJ Holowaychuk</a> 的作品，虽然他已经弃坑了，但是仍然有不小的号召力。和 Sass 有 Compass 类似，Stylus 有一个官方开发的样式库 <a href="http://tj.github.io/nib/" target="_blank" rel="external">nib</a>，同样提供了不少好用的 mixin。对于比较有经验的开发者，用 Stylus 可能更会有一种畅快的感觉。总的来说用一个词形容 Stylus 的话，我会用「sexy」。</p>
<p>总的来说，三种预处理器百分之七八十的功能是类似的。Less 适合帮助团队更快地上手预处理代码的开发，而 Sass 和 Stylus 的差异更在于口味。比如有的人喜欢 jQuery 用一个 <code>$</code> 做大部分的事，而另一些人觉得不一样的功能就该有明确的语义上的差别。在这里我不会做具体的推荐。当然，再次声明一下由于我个人接触 Less 开发比较多，所以可能遇到的坑也多一些，文中没有列出 Sass 和 Stylus 的问题并不代表他们没有。</p>
<p>最后打个广告：百度 EFE 目前有一个基于 Less 的样式库 est，以及一个基于 Stylus 的针对移动端的样式库 rider，欢迎大家关注、提交 issue 和 pull request。</p>
<dl>
<dt>
est
</dt>
<dd>
<iframe src="https://ghbtns.com/github-btn.html?user=ecomfe&amp;repo=est&amp;type=star&amp;count=true" frameborder="0" scrolling="0" width="170px" height="20px">
</iframe>
</dd>
<dt>
rider
</dt>
<dd>
<iframe src="https://ghbtns.com/github-btn.html?user=ecomfe&amp;repo=rider&amp;type=star&amp;count=true" frameborder="0" scrolling="0" width="170px" height="20px">
</iframe>
</dd>
</dl>
]]></content>
    <summary type="html">
    <![CDATA[<p>CSS 预处理器是什么？一般来说，它们基于 CSS 扩展了一套属于自己的 DSL，来解决我们书写 CSS 时难以解决的问题：</p>
<ul>
<li>语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；</li>
<li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以<strong>字面量</strong>的形式重复输出，导致难以维护。</li>
</ul>
<p>所以这就决定了 CSS 预处理器的主要目标：提供 CSS 缺失的<em>样式层</em>复用机制、减少冗余代码，提高样式代码的可维护性。这不是锦上添花，而恰恰是<em>雪中送炭</em>。</p>
<p>网上已经有不少对比目前最主流的三个预处理器 Less、Sass 和 Stylus（按字母顺序排名）的文章了，但是似乎都不是很详细，或者内容有些过时。下面我会更详细地探讨一下这三种预处理器的特性和它们的差异。</p>
<p>下面主要会分为如下几方面来讨论：</p>
<ul>
<li>基本语法</li>
<li>嵌套语法</li>
<li>变量</li>
<li><span class="citation">@import</span></li>
<li>混入</li>
<li>继承</li>
<li>函数</li>
<li>逻辑控制</li>
</ul>
<p>事先声明一下，平时我在开发中主要使用的是 Less，所以可能对 Sass 和 Stylus 的熟悉程度稍差一些，比较时主要参考三者官网的语言特性说明，有一些正在开发的功能可能会遗漏。</p>
<p>本文中对 CSS 语法的话术与 MDN 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Syntax">CSS 语法</a>介绍一致。</p>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://efe.baidu.com/tags/CSS/"/>
    
      <category term="Less" scheme="http://efe.baidu.com/tags/Less/"/>
    
      <category term="Sass" scheme="http://efe.baidu.com/tags/Sass/"/>
    
      <category term="Stylus" scheme="http://efe.baidu.com/tags/Stylus/"/>
    
      <category term="mixin" scheme="http://efe.baidu.com/tags/mixin/"/>
    
      <category term="预处理器" scheme="http://efe.baidu.com/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ETpl的演进]]></title>
    <link href="http://efe.baidu.com/blog/etpl-evolution/"/>
    <id>http://efe.baidu.com/blog/etpl-evolution/</id>
    <published>2015-03-15T16:00:00.000Z</published>
    <updated>2015-05-05T00:12:45.000Z</updated>
    <content type="html"><![CDATA[<div class="figure">
<img src="/blog/etpl-evolution/eng.png">
</div>
<p>如果有人看过我写的《AMD系列三部曲 <a href="/blog/dissecting-amd-what/">一</a> <a href="/blog/dissecting-amd-how/">二</a> <a href="/blog/dissecting-amd-loader/">三</a>》，就会知道我是个唐僧。这次，唐僧想说说<a href="http://ecomfe.github.io/etpl/" target="_blank" rel="external">ETpl</a>。</p>
<p><a href="http://ecomfe.github.io/etpl/" target="_blank" rel="external">ETpl</a>是一个JavaScript的模板引擎。JavaScript最广泛被应用于浏览器端，通常JavaScript模板引擎的作用就是生成HTML串。<a href="http://ecomfe.github.io/etpl/" target="_blank" rel="external">ETpl</a>当前的版本是3.0，也就是说，算上最初设计时，它经历了3次技术上比较大的选型。</p>
<p>今天，<a href="http://ecomfe.github.io/etpl/" target="_blank" rel="external">ETpl</a>号称是一个<code>强复用</code>、<code>灵活</code>、<code>高性能</code>的JavaScript模板引擎，有很多<a href="http://ecomfe.github.io/etpl/feature.html" target="_blank" rel="external">别人有或者别人没有的功能</a>，这些都是what。而我一直认为why比what更重要，了解背后的原因、了解思考的过程比知道是什么有更大的收获，所以这次想要啰嗦的，是<a href="http://ecomfe.github.io/etpl/" target="_blank" rel="external">ETpl</a>在走到今天的过程中，那些what背后的why。如果你能忍受我的八婆把它看完，应该多少能有点收获，越到后面技术点越多噢。</p>
<iframe src="https://ghbtns.com/github-btn.html?user=ecomfe&amp;repo=etpl&amp;type=star&amp;count=true" frameborder="0" scrolling="0" width="170" height="20">
</iframe>
<p>因为本篇比较长，开始先求个star支持下呗，反正不花钱</p>
<a id="more"></a>
<h2 id="时我们做了这些事情">1.0时，我们做了这些事情</h2>
<p><a href="http://ecomfe.github.io/etpl/" target="_blank" rel="external">ETpl</a>是没有独立的1.0版本的。在2010年初，我们为一个SPA应用做重构的时候，开发了<a href="https://github.com/ecomfe/er" target="_blank" rel="external">ER - Enterprise RIA</a>框架的1.0版本，当时ER框架自带了一个模板引擎，这就是<a href="http://ecomfe.github.io/etpl/" target="_blank" rel="external">ETpl</a>的1.0。当时的想法很简单，我们要解决下面这些最基本的问题：</p>
<ol style="list-style-type: decimal">
<li>在JavaScript里面写HTML片段的字符串是不人道的，应该写到另外的文件中</li>
<li>有的HTML片段是需要被复用的</li>
<li>同样的数据在一个片段中可能会重复出现多次</li>
</ol>
<h3 id="command语法">Command语法</h3>
<p>我们认为，最基本的单元应该是一个模板片段。我们需要设计一种语法，来描述这样的片段。</p>
<ol style="list-style-type: decimal">
<li>大多数时候我们的模板片段会是HTML，我们不希望放弃Editor本身提供的HTML语法高亮、自动补全等功能，所以我们可以通过特殊格式的HTML注释来描述模板片段</li>
<li>开发时我们可能每一个文件是一个模板片段，构建时为了优化HTTP请求，这些文件需要合并，我们期望合并可以是简单的，直接合并文件内容就行。所以模板片段需要有开始和结束，我们认为标签式是比较好的方式</li>
<li>合并后模板片段需要能够被分别辨认，而且模板片段需要能被复用，所以模板片段需要被命名</li>
<li>最后面临的是命名问题：哪个单词用来描述一个基本的模板片段单元比较合适呢？选来选去，我们选了<code>target</code></li>
</ol>
<p>基于以上，<a href="http://ecomfe.github.io/etpl/" target="_blank" rel="external">ETpl</a>的语法风格在2010年初被最初固定下来了（在很久以后的2013年，我们才让它可定制化）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[target]</span><br><span class="line">start tag: <span class="comment">&lt;!-- target: target-name --&gt;</span></span><br><span class="line">end tag: <span class="comment">&lt;!-- /target --&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们开始设计如何描述复用。自然而然的，把<code>target</code>换成<code>import</code>就行了。在设计的过程中，我们受到一些HTML的启发：input、img之类的标签是可以不用自闭合的，不是每个标签都需要闭合，我们不是写XML。所以，import没有闭合。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[import]</span><br><span class="line">tag: <span class="comment">&lt;!-- import: target-name --&gt;</span></span><br></pre></td></tr></table></figure>
<div class="figure">
<img src="/blog/etpl-evolution/import.png">
</div>
<p>基于以上，一个模板可以这么写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- target: header --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">header</span>&gt;</span>...<span class="tag">&lt;/<span class="title">header</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- /target --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- target: biz1 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- import: header --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"content"</span>&gt;</span>...<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- /target --&gt;</span></span><br></pre></td></tr></table></figure>
<p>举一反三的，还是受到HTML的启发：li、td、body等标签是不需要写闭合的，parser能够自动在合适的位置认为标签已经结束。比如遇到li的start，就知道上一个li应该结束了。所以我们决定支持target自动闭合，让模板编写者少写一点东西。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- target: header --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">header</span>&gt;</span>...<span class="tag">&lt;/<span class="title">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- target: biz1 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- import: header --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"content"</span>&gt;</span>...<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>到这里，从<code>target</code>和<code>import</code>可以看出来，<a href="http://ecomfe.github.io/etpl/" target="_blank" rel="external">ETpl</a>的语法格式已经被固定下来了：</p>
<ol style="list-style-type: decimal">
<li>起始由<code>command-name</code>和<code>command-value</code>组成，<code>:</code>分隔</li>
<li>闭合由<code>/command-name</code>组成</li>
</ol>
<p>罗马不是一天建成的。基于最早的语法形式，我们不断的通过命令扩展功能，加入了if、for，这都是比较常规的事情了。</p>
<h3 id="变量替换">变量替换</h3>
<p>变量替换是模板引擎的基本功能。从下面的例子可以看出，我们使用的变量替换语法比较大众化：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello $&#123;name&#125;!</span><br></pre></td></tr></table></figure>
<p><a href="http://ecomfe.github.io/etpl/" target="_blank" rel="external">ETpl</a>的主要使用场景是HTML生成。在HTML中常用两种转义方式：</p>
<ol style="list-style-type: decimal">
<li>HTML转义，要显示变量值可能是原始的来源于用户输入的串，不转义有危险</li>
<li>URL转义，变量值可能用于图片的src或者a的href</li>
</ol>
<p>我们通过filter的方式，使变量替换过程的中间能够加入一些处理。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello $&#123;name|html&#125;!</span><br></pre></td></tr></table></figure>
<p>大多数变量替换后的内容会用于直接视图显示，所以我们在不写filter的时候，默认使用html filter进行处理。但是还有一些场景我们是期望输出原始值的，我们引入了一个raw filter用于支持这种情况。这样，我们内置了3个filter，这点一直到现在都没变：</p>
<ol style="list-style-type: decimal">
<li>html (default)</li>
<li>url</li>
<li>raw</li>
</ol>
<p>另外，通过etpl.addFilter(name, filter)方法也可以自己添加filter。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">etpl.addFilter(<span class="string">'test'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source + <span class="string">'!'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="母版">母版</h3>
<p>在SPA应用开发的过程中，我们发现在一个应用里，页面类型的种类很可能是固定的几种，基本所有页面都是在相同的页面框架下，不同部分的内容有一定的区分，所以我们立即就加入了母版的功能(有的模板引擎叫做模板继承，其实是一回事)。</p>
<div class="figure">
<img src="/blog/etpl-evolution/master.png">
</div>
<p>母版功能的语法，参考的是Asp.net，使用了<code>master</code>、<code>contentplaceholder</code>、<code>content</code>，下面这个例子应该容易理解：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- target: biz(master = frame) --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- content:header --&gt;</span>header<span class="comment">&lt;!-- /content --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- content:body --&gt;</span>body<span class="comment">&lt;!-- /content --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- content:footer --&gt;</span>footer<span class="comment">&lt;!-- /content --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- master: frame --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">header</span>&gt;</span><span class="comment">&lt;!-- contentplaceholder: header --&gt;</span><span class="tag">&lt;/<span class="title">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="comment">&lt;!-- contentplaceholder: body --&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">footer</span>&gt;</span><span class="comment">&lt;!-- contentplaceholder: footer --&gt;</span><span class="tag">&lt;/<span class="title">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>母版功能再配合import使用，使开发过程中的重复代码量减少很多，特别是对于SPA类型的应用。母版功能是好的，但是，这样的写法真的不友好。我们直到3.0时，才重新改进了它。</p>
<h3 id="data-getter">Data Getter</h3>
<p>根据数据名称生成数据的功能，我们在最早的时候就支持了。可以看看<a href="http://ecomfe.github.io/etpl/example.html#data-getter" target="_blank" rel="external">这个例子</a>。</p>
<p>这个功能有什么用呢？看起来是没啥用的，但是它提供了数据的动态性，让数据可以在render的过程决定：</p>
<ol style="list-style-type: decimal">
<li>数据来源于多对象，有优先级。这种场景其实可以通过merge解决，但for in可能更耗时。</li>
<li>没有数据时需要自动生成一个，然后写入缓存。</li>
</ol>
<p>这个动态的功能在后来我们做模板编译的时候，成为一个性能瓶颈点，但我们巧妙的解决了。</p>
<h3 id="时代的总结">1.0时代的总结</h3>
<p>如果你用过<a href="http://ecomfe.github.io/etpl/" target="_blank" rel="external">ETpl</a>，你会发现它很多东西是最初就有的，一直到现在都没怎么变。这代表最初的设计有很多是现在还适用的，令人高兴。但是有的东西已经发生了变化（比如母版），我们后面会反思这点。</p>
<p>我们就这样走过了两年多。在这两年里，周围的很多商业系统都采用了SPA的模式，也一直是使用这个ER里自带的模板引擎生成HTML，然后通过UI组件二次进行富交互的行为管理。在这两年里，前端模板开始像雨后春笋一样冒出来，但是我们一直没有跟进，一直在停留。直到……</p>
<h2 id="时我们做了这些事情-1">2.0时，我们做了这些事情</h2>
<p>在2012年的时候，我们的很多SPA应用面临同样的问题：由于业务量的爆炸，一次性把所有JS都压缩到一个文件的构建方案已经不能满足需求。各个产品线都各自设计了按需加载的方案，有还算靠谱的或者不靠谱的。在这样的背景下，我们决定开始强制使用AMD。这不单能从根本上解决这个问题，还能获得一些模块组织、依赖管理、包管理方面的好处。这是一个艰难的决定，这意味着我们原有的很多libraries和frameworks都需要AMD化，包括<a href="https://github.com/ecomfe/er" target="_blank" rel="external">ER框架</a>。当时ER框架里不单自带了模板引擎，还自带了<a href="https://github.com/ecomfe/esui" target="_blank" rel="external">ESUI</a>控件库。我们决定按照<a href="https://github.com/ecomfe/spec" target="_blank" rel="external">规范</a>把他们分离出来，作为独立的package提供。这也符合前端发展的趋势。</p>
<p>既然要独立提供，就来一次进化吧。这一次，ETpl的升级吸收了很多意见，增加了很多实用的功能，体积也控制住了：</p>
<h3 id="模板编译">模板编译</h3>
<p>JavaScript模板引擎所谓的模板编译，指的不是编译成机器码，而是解析模板语法，转换成JavaScript代码，再经过new Function，变成可以在当前环境下执行的function。至于这个过程中有什么编译，render过程有什么JIT，由当前运行的JS引擎决定，不是这里关心的内容了。</p>
<p>在2012年，模板编译已经快成为标配了，几乎所有流行的模板引擎都是编译的。显然模板编译能让性能更高，特别是使用一个模板多次render的场景。我们以前没这么做，是因为在现有应用中没有遇到性能瓶颈，而有其他很多事情让我们无暇顾及他。但是当我们决定要去做一个大升级的时候，这无论如何都是不应该缺席的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有模板编译</span></span><br><span class="line"><span class="keyword">var</span> result = etpl.render(source, data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有模板编译</span></span><br><span class="line"><span class="keyword">var</span> render = etpl.compile(source);</span><br><span class="line"><span class="keyword">var</span> result = render(data);</span><br></pre></td></tr></table></figure>
<p>由于ETpl的灵活性（功能强大的filter、data getter功能等），这些东西都会使性能变差。我们期望坚持我们的特点，在此之上做到相对较高的性能。所以，我们采用了一些方法优化我们的编译产物。下面列举一些我还记得的：</p>
<p>一个是根据不同平台生成不同的代码。这个优化主要是因为鸡国用户的老操作系统老浏览器比例还很大。据我所知<a href="https://github.com/aui/artTemplate" target="_blank" rel="external">artTemplate</a>是最早采用这种优化方法的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RENDER_STRING_DECLATION = <span class="string">'var r="";'</span>;</span><br><span class="line"><span class="keyword">var</span> RENDER_STRING_ADD_START = <span class="string">'r+='</span>;</span><br><span class="line"><span class="keyword">var</span> RENDER_STRING_ADD_END = <span class="string">';'</span>;</span><br><span class="line"><span class="keyword">var</span> RENDER_STRING_RETURN = <span class="string">'return r;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">typeof</span> navigator != <span class="string">'undefined'</span> </span><br><span class="line">    &amp;&amp; <span class="regexp">/msie\s*([0-9]+)/i</span>.test( navigator.userAgent )</span><br><span class="line">    &amp;&amp; <span class="built_in">RegExp</span>.$<span class="number">1</span> - <span class="number">0</span> &lt; <span class="number">8</span></span><br><span class="line">) &#123;</span><br><span class="line">    RENDER_STRING_DECLATION = <span class="string">'var r=[],ri=0;'</span>;</span><br><span class="line">    RENDER_STRING_ADD_START = <span class="string">'r[ri++]='</span>;</span><br><span class="line">    RENDER_STRING_RETURN = <span class="string">'return r.join("");'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有数据访问。由于下面的理由，我们不能把<code>${team.name}</code>直接编译成<code>data.team.name</code>，我们只能编译成<code>getVariable('team.name')</code>:</p>
<ol style="list-style-type: decimal">
<li>data支持getter方法</li>
<li>null和undefined的处理</li>
<li>防止中间变量（for、var）更改数据</li>
</ol>
<p>但是在render运行时切分<code>team.name</code>是非常耗时的事情，所以后来我们编译成了<code>getVariable('team.name', ['team', 'name'])</code>，将这部分的工作放到了编译时。</p>
<p>然后，然后我就不记得了，总之还做过一些。好吧，忘了就忘了，重要的是，我们在支持这么多动态特性下，与性能著称的模板引擎们相比运行时间相比几乎是差不多的（感兴趣的可以自己运行<a href="http://ecomfe.github.io/etpl/performance/render-time.html" target="_blank" rel="external">性能测试用例</a>，IE6下请自觉减少运行的数量级）。我们曾经在一个性能要求非常严苛的NodeJS项目中应用，原先用的mustache性能满足不了需求，后来换了etpl，性能测试就通过了。由于项目涉及保密，就不说了。</p>
<p>性能与功能的取舍总是需要平衡的，我们找到了自己的点：强复用、灵活、高性能的JavaScript模板引擎。</p>
<p>p.s. 我记得前段时间，某模板引擎跳出来说自己性能最高，还给出了测试用例。<a href="http://weibo.com/u/1143654280" target="_blank" rel="external">10同学</a>跑了一下，发现ETpl和mustache差不多。我们觉得不应该啊，再一看测试用例，是1000次编译*10000次运行。妈蛋测试不能这样做啊，1000次编译你还要编译干嘛？而且就算要做，也是两个测试用例，编译性能是一个测试用例，运行性能是一个测试用例啊。真能混淆视听。</p>
<h3 id="移动可用">移动可用</h3>
<p>由于模板编译已经把性能考虑掉了，这里主要考虑的是体积的大小。移动方向负责人<a href="http://weibo.com/u/1653095744" target="_blank" rel="external">Firede</a>给的指标是，ETpl语法压缩+GZip后不能超过4k。</p>
<p>关键是ETpl的特点是复用能力和灵活性啊，有这么多功能就有这么多代码，我们总不能砍功能最后变成再做一个doT或者artTemplate出来吧那就没必要再写了啊，妈蛋只能进行体积优化了啊。我知道的另外一个复用功能比较强大的模板引擎<a href="http://mozilla.github.io/nunjucks/" target="_blank" rel="external">nunjucks</a>语法压缩+GZip后是19k。</p>
<p>我专门抽了将近一周时间一点一点砍体积。说实话这是个体力活，是个精细化的活。优化过程中还经常会出现觉得这么做体积能减小一点，做了以后发现和预想的不一样，增加了几个字节，只好撤销，重新读代码去寻找优化点。优化进行了4天后（达到小于4k后，已经和自己较劲上了，根本就停不下来啊），体积是3.7k，感觉已经接近x尽人亡了。好多点都已经不记得了，就说两个记得的比较大的点吧。</p>
<p>把相似的代码尽量放到一起。下面的代码可以看出来，<code>Command.prototype.open = function (context) {</code>相同片段的代码都放的比较近，更利于GZip。同样的，很多Constructor中代码比较接近，所以作为Constructor的function都放到了一起声明。可读性党在这里会不会跳出来？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">UseCommand.prototype.open = <span class="function"><span class="keyword">function</span> <span class="params">(context)</span> </span>&#123;</span><br><span class="line">    context.stack.top().addChild(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BlockCommand.prototype.open = <span class="function"><span class="keyword">function</span> <span class="params">(context)</span> </span>&#123;</span><br><span class="line">    Command.prototype.open.call(<span class="keyword">this</span>, context);</span><br><span class="line">    (context.imp || context.target).blocks[<span class="keyword">this</span>.name] = <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ElifCommand.prototype.open = <span class="function"><span class="keyword">function</span> <span class="params">(context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elseCommand = <span class="keyword">new</span> ElseCommand();</span><br><span class="line">    elseCommand.open(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ifCommand = autoCloseCommand(context, IfCommand);</span><br><span class="line">    ifCommand.addChild(<span class="keyword">this</span>);</span><br><span class="line">    context.stack.push(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再看看下面inherits的实现，简化了不少。注释已经写的很清楚了。可维护性党在这里会不会跳出来？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span><span class="params">(subClass, superClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line">    F.prototype = superClass.prototype;</span><br><span class="line">    subClass.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    subClass.prototype.constructor = subClass;</span><br><span class="line">    <span class="comment">// 由于引擎内部的使用场景都是inherits后，逐个编写子类的prototype方法</span></span><br><span class="line">    <span class="comment">// 所以，不考虑将原有子类prototype缓存再逐个拷贝回去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="支持不写target">支持不写target</h3>
<p>不是所有模板片段都需要被复用，他们可以作为单独的模板片段，编译一次，多次使用。这在很多小的字符串片段的生成中还是比较常见的。所以有的模板就不需要被命名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> helloRender = etpl.compile(<span class="string">'Hello $&#123;name&#125;'</span>);</span><br><span class="line">helloRender(&#123;</span><br><span class="line">    name: <span class="string">'ETpl'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里支持的技术方法很简单：</p>
<ol style="list-style-type: decimal">
<li>原来每个target都是具名的，这点内部实现还是不变。当遇到模板源码的起始不是target的时候，就自动创建一个target，并自动生成一个不重复的名字。</li>
<li>compile方法返回第一个target的编译结果。</li>
</ol>
<h3 id="通过配置项定义语法风格">通过配置项定义语法风格</h3>
<p>最初我们的初衷是期望在写模板的时候，不要丢失Editor对HTML的一些语法高亮、自动补全等功能的支持，所以模板语法是写在HTML注释里的。后来我们发现不少人不喜欢这种风格：</p>
<ol style="list-style-type: decimal">
<li>习惯了其他的风格，比如<code>&lt;%</code>和<code>%&gt;</code></li>
<li>HTML注释要输入的开始和结束很长啊，分别是4个字符和3个字符</li>
</ol>
<p>所以我们决定支持一些配置项，让用户可以自己定制语法风格。最开始支持的是<code>commandOpen</code>和<code>commandClose</code>。再后来，我们又发现由于mustache的流行，很多人习惯 <strong></strong> 的变量替换风格。所以我们又支持了<code>variableOpen</code>和<code>variableClose</code>。</p>
<p>于是，如果你有如下的配置：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">etpl.config(&#123;</span><br><span class="line">    commandOpen: '<span class="tag">&lt;<span class="title">%',</span></span><br><span class="line">    <span class="attribute">commandClose:</span> '%&gt;</span>',</span><br><span class="line">    variableOpen: '\&#123;\&#123;',</span><br><span class="line">    variableClose: '\&#125;\&#125;'</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>你的模板可能会是这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">%</span> <span class="attribute">target:</span> <span class="attribute">header</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">header</span>&gt;</span>...<span class="tag">&lt;/<span class="title">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">%</span> <span class="attribute">target:</span> <span class="attribute">biz1</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">%</span> <span class="attribute">import:</span> <span class="attribute">header</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"content"</span>&gt;</span>Hello &#123;&#123;name&#125;&#125;!<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="多引擎实例">多引擎实例</h3>
<p>随着业务规模的爆炸，一个应用开发人数增多，以及开发过程管理不够科学，有的团队遇到了模板片段命名上出现冲突的问题。简单的一个例子，两个功能都有列表页，大家都为模板片段起名叫list，就会冲突。</p>
<p>对业务功能进行统一管理，并制定合理的规范，在执行上有效监督，是能避免这个问题的。但是不一定每个团队都能做到这一点，而且既然发现问题，在技术手段上能解决，我们就解决。</p>
<p>解决的方法很简单，就是etpl支持多引擎实例，不同引擎实例之间完全隔离，就可以拥有相同名称不同内容的模板，甚至不同引擎可以各自定义自己的模板语法格式。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var engine = new etpl.Engine(&#123;</span><br><span class="line">    commandOpen: '<span class="tag">&lt;<span class="title">%',</span></span><br><span class="line">    <span class="attribute">commandClose:</span> '%&gt;</span>',</span><br><span class="line">    variableOpen: '\&#123;\&#123;',</span><br><span class="line">    variableClose: '\&#125;\&#125;'</span><br><span class="line">&#125;)</span><br><span class="line">var render = engine.compile('Hello &#123;&#123;name&#125;&#125;!');</span><br><span class="line">render(&#123;name: 'myName'&#125;);</span><br></pre></td></tr></table></figure>
<p><code>etpl</code>这个变量本身是默认一开始就初始化好的一个引擎实例。</p>
<h3 id="在模板里定义数据">在模板里定义数据</h3>
<p>我们对提供模板中声明数据的能力一直持谨慎的态度，但后来我们决定支持它。</p>
<ol style="list-style-type: decimal">
<li>有的东西在写模板时也可以被抽取成为数据，在内容串中多次用到</li>
<li>一些特性、行为选择可以抽取作为数据配置项</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- var: name = 'etpl' --&gt;</span></span><br><span class="line"></span><br><span class="line">Hello $&#123;name&#125;!</span><br><span class="line"><span class="comment">&lt;!-- if: score &gt; 90 --&gt;</span></span><br><span class="line">$&#123;name&#125; is clever!</span><br><span class="line"><span class="comment">&lt;!-- /if --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="动态调用">动态调用</h3>
<p>原先我们通过<code>import</code>可以实现复用，其效果相当于把目标模板片段的源码嵌入相应位置。但是请看下面的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- target: grade --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h3</span>&gt;</span>class1<span class="tag">&lt;/<span class="title">h3</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- var: members = class1.members --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- import: members --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">h3</span>&gt;</span>class2<span class="tag">&lt;/<span class="title">h3</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- var: members = class2.members --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- import: members --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- target: members --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- for: $&#123;members&#125; as $&#123;member&#125; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span>$&#123;member.name&#125;<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /for --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>members模板片段提供了把一群人打印出来的能力，但是这群人的数据名称被固定了，必须是members。在我们只能使用<code>import</code>时，一般同学会写两遍，很聪明的同学会想到上面这样的方法来复用，真是难为了。</p>
<p>所以，我们在2.0通过<code>use</code>支持了动态调用的特性，其效果相当于JavaScript中的函数调用。调用传入数据的方式是名称对应，不是顺序对应，因为模板片段声明时只会声明名称，不会声明其用到的数据。模板引擎能这么玩还是不多见的，所以说复用和灵活是<a href="http://ecomfe.github.io/etpl/" target="_blank" rel="external">ETpl</a>最大特点。</p>
<div class="figure">
<img src="/blog/etpl-evolution/use.png">
</div>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- target: grade --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h3</span>&gt;</span>class1<span class="tag">&lt;/<span class="title">h3</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- use: members(members=class1.members) --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">h3</span>&gt;</span>class2<span class="tag">&lt;/<span class="title">h3</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- use: members(members=class2.members) --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- target: members --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- for: $&#123;members&#125; as $&#123;member&#125; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span>$&#123;member.name&#125;<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /for --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="filter支持参数">filter支持参数</h3>
<p>在1.0时代，filter是一个非常简单的功能。在2.0中，我们对它专门进行了设计，增加了很多特性。</p>
<h4 id="对参数的支持">对参数的支持</h4>
<p>我们希望filter在运行时能够根据一些参数，进行不同行为的处理。比如下面的应用场景，支持参数是非常有用的：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;</span>birthday | dateFormat(<span class="string">'yyyy-MM-dd'</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>在addFilter时，我们有两种方案可以选择：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1，参数紧跟在filter函数的source参数后</span></span><br><span class="line">etpl.addFilter(<span class="string">'dateFormat'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(source, format)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2，闭包根据</span></span><br><span class="line">etpl.addFilter(<span class="string">'dateFormat'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(format)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>方案2的优势是，如果后续filter还有什么扩展，能够更方便。最后，由于性能和filter开发的易理解上的考虑，我们最终选择了方案1。</p>
<h4 id="对管道的支持">对管道的支持</h4>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;</span>content | cut(<span class="number">200</span>) | highlight(<span class="variable">$&#123;</span>keyword&#125;)&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，在一些场景下，一个完成独立功能的filter不足以完成一些需求，这个时候，我们可能需要add一个新的filter，其功能是另外两个filter的组合。这事情是多此一举的。我们从shell的管道得到启发，我们让filter功能也支持了管道。</p>
<p>换一个简单的例子：<code>${team.name | slice(1, 3) | html}</code>，下面是其模板编译的结果说明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">filters.html(</span><br><span class="line">    filters.slice(</span><br><span class="line">        toString(</span><br><span class="line">            getVariable(</span><br><span class="line">                ‘team.name’,</span><br><span class="line">                [‘team’,’name’]</span><br><span class="line">            )</span><br><span class="line">        ),</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>从上面的模板编译结果说明，我们发现在getVariable和filters.slice之间，有一个toString，为什么呢？</p>
<h4 id="参数类型的考虑">参数类型的考虑</h4>
<p>在仔细设计filter功能的时候，我们对参数类型的问题，进行了一次深入的讨论。包括后来，很多使用者也问过我们为什么是这样。我们通过下面的应用场景对这个问题进行说明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: <span class="string">'erik'</span></span><br><span class="line">    birthday: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2007</span>, <span class="number">6</span>, <span class="number">11</span>),</span><br><span class="line">    sex: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;name | html&#125; was born in $&#123;birthday | dateFormat('yyyy-MM-dd')&#125;.</span><br></pre></td></tr></table></figure>
<p>filter应该接受数据的原始类型，还是字符串呢？</p>
<p>接受原始类型，dateFormat会比较容易处理。但是存在如下问题：</p>
<ol style="list-style-type: decimal">
<li>管道的输入和输出应该保持一致性，否则容易导致混乱</li>
<li>每个filter开发都需要做类型判断和转换。比如cut filter的功能是字符串截断，它需要内部将输入转换成字符串，因为输入可能是数字，不转换就会报错。</li>
</ol>
<p>我们认为：</p>
<ol style="list-style-type: decimal">
<li>默认情况下，在变量替换中，将默认一开始就把数据转换成字符串。filter的返回也应该是字符串。从而保证filter管道的数据类型一致性。</li>
<li>我们也应该提供一种途径，方便一些特殊的filter进行处理，使其内部不需要进行字符串到所需数据类型的反序列化。我们选择的方式是<code>${*variable | filter}</code>：当variable使用<code>*</code>前缀时，ETpl默认不将variable转换成字符串，直接将原始数据传递给filter进行处理。这时filter中的处理过程是干净的，模板编写者需要知道filter是怎么干的，从而决定是否给filter原始数据。</li>
</ol>
<p>所以，上面的模板例子，正确形式应该是这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;name | html&#125; was born in $&#123;*birthday | dateFormat('yyyy-MM-dd')&#125;.</span><br></pre></td></tr></table></figure>
<p>约定输入必须是字符串，我们也才能顺利实现后面的 <strong>处理模板内容块</strong> 功能。</p>
<h4 id="处理模板内容块">处理模板内容块</h4>
<p>filter的功能能够对目标内容进行一些处理，但是变量替换中的filter只能处理数据中的内容，我们可能需要对一些模板里的内容，使用filter进行处理。我们通过一个叫做filter的命令，实现了这样的功能。下面的代码是我们对于需求的最初设想：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- filter: markdown --&gt;</span></span><br><span class="line">## markdown document</span><br><span class="line"></span><br><span class="line">This is the content, also I can use `$&#123;variables&#125;`</span><br><span class="line"><span class="comment">&lt;!-- /filter --&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们很兴奋的支持了这个功能，但是迄今为止还没在应用中用到。</p>
<h3 id="母版的母版">母版的母版</h3>
<p>在1.0时代，我们支持了母版功能，但是只有target可以指定master。遇到下面这样的场景，就得写多个母版，每个母版里还有很多重复的内容。</p>
<p>所以在2.0里，我们支持了这样的功能，母版也能指定母版：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- master: up-down --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- contentplaceholder: header --&gt;</span>header<span class="comment">&lt;!-- /contentplaceholder --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- contentplaceholder: body --&gt;</span>body<span class="comment">&lt;!-- /contentplaceholder --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- master: up-left-right(master = up-down) --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- content: header --&gt;</span>my header<span class="comment">&lt;!-- /content --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- content: body --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">aside</span>&gt;</span><span class="comment">&lt;!-- contentplaceholder: body-side --&gt;</span><span class="tag">&lt;/<span class="title">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">main</span>&gt;</span><span class="comment">&lt;!-- contentplaceholder: body-main --&gt;</span>child body<span class="comment">&lt;!-- /contentplaceholder --&gt;</span><span class="tag">&lt;/<span class="title">main</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- /content --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- target: biz(master = up-left-right) --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- content: body-side --&gt;</span>biz aside<span class="comment">&lt;!-- /content --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- content: body-main --&gt;</span>biz main<span class="comment">&lt;!-- /content --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="时代的总结-1">2.0时代的总结</h3>
<p>由于ETpl独立化的契机，我们精心设计了2.0，加入了很多我们认为应该支持的功能。在这个过程中我们依然是谨慎的，我们没有忘记“复用、灵活”的初衷，并且努力实现“高性能，小体积”。从1.0到2.0，我们完成了 <strong>还算好用</strong> 到 <strong>敢见人</strong> 的转变。</p>
<h2 id="时我们做了这些事情-2">3.0时，我们做了这些事情</h2>
<p>在2.0中，我们已经做了一些比较完善的工作。但是在设计2.0的时候，我们期望尽量能够平滑的升级。我们增加特性，也要保证在现有系统中存在的模板能够正常的运行。但是不可否认，从1.0沿袭下来的2.0在母版功能的语法上存在不好用的地方，可以改进。</p>
<ol style="list-style-type: decimal">
<li>master和target为什么非要区分？master也是模板片段，直接用来渲染按道理应该是可以的。</li>
<li>contentplaceholder是什么东西？谁能记住这个不止一个单词的货色妈蛋？</li>
</ol>
<p>我们一直有所感觉，但没有着手去做这个事情。因为我们知道这是一个breaking change，在一个已经被广泛应用的东西上做breaking change是需要谨慎、需要足够充足的理由的，但我们一直没找到，直到……</p>
<h3 id="引用代入">引用代入</h3>
<p>直到<a href="http://otakustay.com/" target="_blank" rel="external">灰大</a>提出了<a href="https://github.com/ecomfe/etpl/issues/31" target="_blank" rel="external">issue31</a>!</p>
<p>这是个令人振奋的功能，迄今为止我没有见过市面上哪个模板引擎提供了这样的功能。我把它叫做<a href="http://ecomfe.github.io/etpl/feature.html#import-block" target="_blank" rel="external">引用代入</a>，意思是：在我<code>import</code>一个模板片段的时候，我能够对它中间的部分内容进行复写。</p>
<div class="figure">
<img src="/blog/etpl-evolution/import-rewrite.png">
</div>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- target: header --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">header</span>&gt;</span><span class="comment">&lt;!-- block: header --&gt;</span>default header<span class="comment">&lt;!-- /block --&gt;</span><span class="tag">&lt;/<span class="title">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- target: main --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="comment">&lt;!-- block: main --&gt;</span>default list<span class="comment">&lt;!-- /block --&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- target: footer --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">footer</span>&gt;</span><span class="comment">&lt;!-- block: footer --&gt;</span>default footer<span class="comment">&lt;!-- /block --&gt;</span><span class="tag">&lt;/<span class="title">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- target: biz --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- import: header --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- import: main --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- block: main --&gt;</span>specical list<span class="comment">&lt;!-- /block --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- /import --&gt;</span></span><br></pre></td></tr></table></figure>
<p>这能够有效避免在大应用中的母版爆炸问题，有效减少代码量！具体他是什么，能做什么，上面的issue里写得很清楚了，感兴趣的人去看看吧，相信大家会有收获。</p>
<p>这个feature给了我们给ETpl升级一位版本号的理由，因为它太令人振奋了。当然迄今为止用到这个feature的人并不多，因为大家还没明白它的好处，但我强烈建议大家去看看上面的issue！！！这里也有一个<a href="http://ecomfe.github.io/etpl/example.html#import-block" target="_blank" rel="external">引用代入的例子</a>。</p>
<h3 id="对母版功能的语法重设计">对母版功能的语法重设计</h3>
<p>我承认标题吹牛逼了，我们其实没有重设计。流行的模板引擎早已经有成熟的语法了，我们就是改成那样而已。这事情的意义是：梗终于被拔掉了。</p>
<p>方案是：我们砍掉了<code>master</code>、<code>content</code>、<code>contentplaceholder</code>，引入了<code>block</code>。</p>
<div class="figure">
<img src="/blog/etpl-evolution/newmaster.png">
</div>
<p>回顾上面多重母版的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- master: up-down --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- contentplaceholder: header --&gt;</span>header<span class="comment">&lt;!-- /contentplaceholder --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- contentplaceholder: body --&gt;</span>body<span class="comment">&lt;!-- /contentplaceholder --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- master: up-left-right(master = up-down) --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- content: header --&gt;</span>my header<span class="comment">&lt;!-- /content --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- content: body --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">aside</span>&gt;</span><span class="comment">&lt;!-- contentplaceholder: body-side --&gt;</span><span class="tag">&lt;/<span class="title">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">main</span>&gt;</span><span class="comment">&lt;!-- contentplaceholder: body-main --&gt;</span>child body<span class="comment">&lt;!-- /contentplaceholder --&gt;</span><span class="tag">&lt;/<span class="title">main</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- /content --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- target: biz(master = up-left-right) --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- content: body-side --&gt;</span>biz aside<span class="comment">&lt;!-- /content --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- content: body-main --&gt;</span>biz main<span class="comment">&lt;!-- /content --&gt;</span></span><br></pre></td></tr></table></figure>
<p>在3.0时代就变成了这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- target: up-down --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">header</span>&gt;</span><span class="comment">&lt;!-- block: header --&gt;</span>header<span class="comment">&lt;!-- /block --&gt;</span><span class="tag">&lt;/<span class="title">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="comment">&lt;!-- block: body --&gt;</span>body<span class="comment">&lt;!-- /block --&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- target: up-left-right(master = up-down) --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- block: header --&gt;</span>my header<span class="comment">&lt;!-- /block --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- block: body --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">aside</span>&gt;</span><span class="comment">&lt;!-- block: body-side --&gt;</span><span class="tag">&lt;/<span class="title">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">main</span>&gt;</span><span class="comment">&lt;!-- block: body-main --&gt;</span>child body<span class="comment">&lt;!-- /block --&gt;</span><span class="tag">&lt;/<span class="title">main</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- /block --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- target: biz(master = up-left-right) --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- block: body-side --&gt;</span>biz aside<span class="comment">&lt;!-- /block --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- block: body-main --&gt;</span>biz main<span class="comment">&lt;!-- /block --&gt;</span></span><br></pre></td></tr></table></figure>
<p>爽很多，有木有？但是毕竟是breaking change，很多ETpl2语法编写的模板迁移成本会很高。所以我们还提供了<a href="https://github.com/ecomfe/etpl2to3" target="_blank" rel="external">etpl2to3</a>的工具帮助老的产品线自动转换，基本迁移就可以无缝了。</p>
<h3 id="支持完全自定义模板语法">支持完全自定义模板语法</h3>
<p>我们之前通过 <code>commandOpen</code> / <code>commandClose</code> / <code>variableOpen</code> / <code>variableClose</code> 配置项支持用户对部分语法部分进行定制，但是<code>var: a = 1</code>中间的冒号算怎么回事，怎么觉得这么别扭呢？</p>
<p>所以，我们增加了一个参数：<code>commandSyntax</code>，让用户能够对命令的语法规则进行定制。看看<a href="http://ecomfe.github.io/etpl/example.html#custom" target="_blank" rel="external">这个例子</a>，经过定制后，ETpl语法和nunjucks是一样的。</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">%</span> <span class="attribute">target</span> <span class="attribute">myTpl</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">%</span> <span class="attribute">import</span> <span class="attribute">header</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"main"</span>&gt;</span>Hello </span><span class="expression">&#123;&#123;<span class="variable">name</span>&#125;&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">%</span> <span class="attribute">import</span> <span class="attribute">footer</span> %&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">%</span> <span class="attribute">target</span> <span class="attribute">header</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">header</span>&gt;</span>Header Content<span class="tag">&lt;/<span class="title">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">%</span> <span class="attribute">target</span> <span class="attribute">footer</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">footer</span>&gt;</span>Footer Content<span class="tag">&lt;/<span class="title">footer</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><code>commandSyntax</code>类型是一个正则，默认值是<code>^\s*(\/)?([a-z]+)\s*(?::([\s\S]*))?$</code>，第一个match是结束标记，第二个match是command name，第三个match是command value。使用符合规则的正则就能很方便的定制ETpl的语法咯。</p>
<p>在2.0的时候我们也隐约感觉应该开放这样的定制点，但时间总是有限的，我们还在做其他的事情。当我们决定升级3.0的时候，我们就会把之前觉得不太紧急的升级点，仔细考虑，一并做掉。所以自定义模板语法的支持，在3.0才算是真正完全实现。</p>
<h2 id="最后">最后</h2>
<p>跌跌撞撞的，<a href="http://ecomfe.github.io/etpl/" target="_blank" rel="external">ETpl</a>存在到现在也有4年多了。中间的升级一直断断续续，我们走的不快，但是还算稳。在这个过程中，对于lib类型的产品，我们有一些感想：</p>
<ol style="list-style-type: decimal">
<li>很多基因在最开始的时候就已经被决定了。我们一开始最关注提供中大型应用中的模板复用性和灵活性，到最后这也是我们最厉害的地方。</li>
<li>定位很重要，定位一定是一个取舍。讲性能我们比不过<a href="https://github.com/aui/artTemplate" target="_blank" rel="external">artTemplate</a>，讲体积我们比不过<a href="http://olado.github.io/doT/" target="_blank" rel="external">doT</a>，我们有我们的特点和生存空间。</li>
<li>结合应用实际很重要。我们的功能点有很多是来源于应用后的反馈。绝对不能只高屋建瓴的空想。</li>
<li>用户量越多，包袱越大。就像我们没法随意更改其语法。所以每个设计点都应该谨慎决策。</li>
<li>用户通常只能看到你的第一价值观。就像我们提供了语法定制的功能，但是绝大多数用户是不会用的，他们会根据是否喜欢你提供的默认语法形式，决定用不用你。</li>
</ol>
<p>我们仍有没做的功能，比如预编译。原因如下：</p>
<ol style="list-style-type: decimal">
<li>预编译后的代码大多数时候比模板本身要大，可见预编译对浏览器端应用是没有价值的。</li>
<li>对于NodeJS应用，服务启动时编译一次的成本并不高。</li>
<li>filter功能对于预编译是一个障碍，我们无法平滑的完成预编译的过程，filter可能是一个位于复杂环境的function。</li>
</ol>
<p>所以，我们还未决定是否进行预编译的支持。当然，主要是因为我们现在还没有时间仔细的审视这个问题并给出方案。在未来的某个时候，我们将会考虑。</p>
<p>如果你觉得本篇blog有点收获，求个star支持下呗，反正不花钱</p>
<iframe src="https://ghbtns.com/github-btn.html?user=ecomfe&amp;repo=etpl&amp;type=star&amp;count=true" frameborder="0" scrolling="0" width="170" height="20">
</iframe>
]]></content>
    <summary type="html">
    <![CDATA[<div class="figure">
<img src="/blog/etpl-evolution/eng.png" />
</div>
<p>如果有人看过我写的《AMD系列三部曲 <a href="/blog/dissecting-amd-what/">一</a> <a href="/blog/dissecting-amd-how/">二</a> <a href="/blog/dissecting-amd-loader/">三</a>》，就会知道我是个唐僧。这次，唐僧想说说<a href="http://ecomfe.github.io/etpl/">ETpl</a>。</p>
<p><a href="http://ecomfe.github.io/etpl/">ETpl</a>是一个JavaScript的模板引擎。JavaScript最广泛被应用于浏览器端，通常JavaScript模板引擎的作用就是生成HTML串。<a href="http://ecomfe.github.io/etpl/">ETpl</a>当前的版本是3.0，也就是说，算上最初设计时，它经历了3次技术上比较大的选型。</p>
<p>今天，<a href="http://ecomfe.github.io/etpl/">ETpl</a>号称是一个<code>强复用</code>、<code>灵活</code>、<code>高性能</code>的JavaScript模板引擎，有很多<a href="http://ecomfe.github.io/etpl/feature.html">别人有或者别人没有的功能</a>，这些都是what。而我一直认为why比what更重要，了解背后的原因、了解思考的过程比知道是什么有更大的收获，所以这次想要啰嗦的，是<a href="http://ecomfe.github.io/etpl/">ETpl</a>在走到今天的过程中，那些what背后的why。如果你能忍受我的八婆把它看完，应该多少能有点收获，越到后面技术点越多噢。</p>
<iframe src="https://ghbtns.com/github-btn.html?user=ecomfe&amp;repo=etpl&amp;type=star&amp;count=true" frameborder="0" scrolling="0" width="170" height="20">
</iframe>
<p>因为本篇比较长，开始先求个star支持下呗，反正不花钱</p>]]>
    
    </summary>
    
      <category term="ETpl" scheme="http://efe.baidu.com/tags/ETpl/"/>
    
      <category term="JavaScript" scheme="http://efe.baidu.com/tags/JavaScript/"/>
    
      <category term="模板引擎" scheme="http://efe.baidu.com/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[中文字体 webfont 自动化构建]]></title>
    <link href="http://efe.baidu.com/blog/chinese-font-build/"/>
    <id>http://efe.baidu.com/blog/chinese-font-build/</id>
    <published>2015-03-11T16:00:00.000Z</published>
    <updated>2015-03-12T23:47:10.000Z</updated>
    <content type="html"><![CDATA[<div class="figure">
<img src="/blog/chinese-font-build/img/history.gif">
</div>
<p>关于字体，长久以来，前端工程师们 进行了各种探索：<code>图片</code>，<code>siFR</code>，<code>Cufon</code>，<code>@font-face</code> …</p>
<p><code>@font-face</code> 似乎是个不错的方案，<a href="https://typekit.com/fonts" target="_blank" rel="external">Adobe TypeKit</a> , <a href="http://www.google.com/fonts/" target="_blank" rel="external">Google Fonts</a> 都在使用这个方案。但是，中文字体 因为字符集巨大，浏览器、操作系统国情 等原因，发展受到了很大限制。所以，时至今日，大多数网站的中文字体还是上图片。图片字体的悲伤：SEO 不友好，不具备的可编辑性，不支持 <a href="http://en.wikipedia.org/wiki/Accessibility" target="_blank" rel="external">Accessibility</a> 原则 … 差评！</p>
<p>随着 <code>PC</code> 的更新换代，操作系统的升级，移动设备的崛起，<code>@font-face</code> 兼容性已经不足为患。<code>ttf</code>, <code>svg</code>, <code>eot</code>, <code>woff</code> 总有一款适合您。那么剩下的主要问题就是中文字符集过大了。</p>
<p>以上，我们的解决方案就是：基于 <a href="https://github.com/ecomfe/edp" target="_blank" rel="external">edp</a> 和 <a href="https://github.com/ecomfe/fontmin" target="_blank" rel="external">fontmin</a>，按需提取字型，多格式转换，自动化构建字体。</p>
<a id="more"></a>
<h3 id="首先你要有个-edp">首先，你要有个 <code>edp</code></h3>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> -g edp</span><br></pre></td></tr></table></figure>
<h3 id="示例">示例</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/junmer/edp-build-fontmin-demo    <span class="comment"># 下载 示例项目</span></span><br><span class="line">$ <span class="built_in">cd</span> edp-build-fontmin-demo                                     <span class="comment"># 进入 示例项目 路径</span></span><br><span class="line">$ npm install edp-build-fontmin                                 <span class="comment"># 安装 edp-build-fontmin 依赖</span></span><br><span class="line">$ edp build <span class="operator">-f</span>                                                  <span class="comment"># 开始构建</span></span><br></pre></td></tr></table></figure>
<h3 id="配置">配置</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FontProcessor = <span class="built_in">require</span>(<span class="string">'edp-build-fontmin'</span>);</span><br><span class="line"><span class="keyword">var</span> fontProcessor = <span class="keyword">new</span> FontProcessor(&#123;</span><br><span class="line">    files: [ <span class="string">'*.ttf'</span> ],                     <span class="comment">// 字体文件</span></span><br><span class="line">    entryFiles: [ <span class="string">'*.html'</span> ],               <span class="comment">// 引用字体的网页，用来扫描所需字型</span></span><br><span class="line">    text: <span class="string">'他夏了夏天'</span>,                       <span class="comment">// 人肉配置所需字型</span></span><br><span class="line">    chineseOnly: <span class="literal">true</span>,                      <span class="comment">// 只取中文字型，忽略 数字、英文、标点</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="效果">效果</h3>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ edp ws <span class="built_in">start</span></span><br></pre></td></tr></table></figure>
<p>打开 <code>http://127.0.0.1:8848/</code> 和 <code>http://127.0.0.1:8848/output/</code> 对比效果</p>
<p>构建前:</p>
<div class="figure">
<img src="/blog/chinese-font-build/img/before.png">
</div>
<p>构建后:</p>
<div class="figure">
<img src="/blog/chinese-font-build/img/after.png">
</div>
<p>字体文件 <code>5.1 MB</code> -&gt; <code>29.1 KB</code>, 效果 萌萌哒 (￣y▽￣)~*</p>
<h3 id="相关项目">相关项目</h3>
<ul>
<li><a href="https://github.com/ecomfe/edp" target="_blank" rel="external">edp</a> 一个基于 Node.JS 与 NPM 的企业级前端应用的开发平台</li>
<li><a href="https://github.com/ecomfe/fontmin" target="_blank" rel="external">fontmin</a> 第一个纯 JS 字体解决方案</li>
<li><a href="https://github.com/ecomfe/edp-build-fontmin" target="_blank" rel="external">edp-build-fontmin</a> edp fontmin 插件</li>
<li><a href="http://font.baidu.com/editor/" target="_blank" rel="external">fonteditor</a> 在线字体编辑器</li>
</ul>
<h3 id="致敬">致敬</h3>
<ul>
<li>题图：<a href="http://blog.typeland.com/articles/169" target="_blank" rel="external">汉字书体年表</a> by <a href="http://blog.typeland.com/" target="_blank" rel="external">typeland</a></li>
<li>示例字体：<a href="http://font.sentywed.com/index_htm_files/SentyTEA-Platinum.ttf" target="_blank" rel="external">新蒂下午茶体</a> 非商业免费授权，商业授权请联系 <a href="http://font.sentywed.com/" target="_blank" rel="external">新蒂字体</a></li>
<li>示例文字：<a href="http://music.baidu.com/song/218698/07053564a0854da1aa8" target="_blank" rel="external">他夏了夏天</a> by 苏打绿</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<div class="figure">
<img src="/blog/chinese-font-build/img/history.gif" />
</div>
<p>关于字体，长久以来，前端工程师们 进行了各种探索：<code>图片</code>，<code>siFR</code>，<code>Cufon</code>，<code>@font-face</code> …</p>
<p><code>@font-face</code> 似乎是个不错的方案，<a href="https://typekit.com/fonts">Adobe TypeKit</a> , <a href="http://www.google.com/fonts/">Google Fonts</a> 都在使用这个方案。但是，中文字体 因为字符集巨大，浏览器、操作系统国情 等原因，发展受到了很大限制。所以，时至今日，大多数网站的中文字体还是上图片。图片字体的悲伤：SEO 不友好，不具备的可编辑性，不支持 <a href="http://en.wikipedia.org/wiki/Accessibility">Accessibility</a> 原则 … 差评！</p>
<p>随着 <code>PC</code> 的更新换代，操作系统的升级，移动设备的崛起，<code>@font-face</code> 兼容性已经不足为患。<code>ttf</code>, <code>svg</code>, <code>eot</code>, <code>woff</code> 总有一款适合您。那么剩下的主要问题就是中文字符集过大了。</p>
<p>以上，我们的解决方案就是：基于 <a href="https://github.com/ecomfe/edp">edp</a> 和 <a href="https://github.com/ecomfe/fontmin">fontmin</a>，按需提取字型，多格式转换，自动化构建字体。</p>]]>
    
    </summary>
    
      <category term="font" scheme="http://efe.baidu.com/tags/font/"/>
    
      <category term="tool" scheme="http://efe.baidu.com/tags/tool/"/>
    
      <category term="中文字体" scheme="http://efe.baidu.com/tags/%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[嵌套条件的重构]]></title>
    <link href="http://efe.baidu.com/blog/replace-nested-conditional-with-guard-clauses/"/>
    <id>http://efe.baidu.com/blog/replace-nested-conditional-with-guard-clauses/</id>
    <published>2015-03-08T16:00:00.000Z</published>
    <updated>2015-03-09T01:19:24.000Z</updated>
    <content type="html"><![CDATA[<p>嵌套的条件判断会导致方法的正常执行路径不明晰，使代码可读性下降。本文提供一种对嵌套条件重构的方法，能有效提升代码的可读性。</p>
<p>原文：<a href="http://sourcemaking.com/refactoring/replace-nested-conditional-with-guard-clauses" class="uri" target="_blank" rel="external">http://sourcemaking.com/refactoring/replace-nested-conditional-with-guard-clauses</a></p>
<p>条件判断会导致方法的正常执行路径不明晰。</p>
<p>特例一概使用 <code>Guard Clauses</code>。</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPayAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">if</span> (_isDead) &#123;</span><br><span class="line">        result = deadAmount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_isSeparated) &#123;</span><br><span class="line">            result = separatedAmount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_isRetired) &#123;</span><br><span class="line">                result = retiredAmount();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result = normalPayAmount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPayAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_isDead) &#123;</span><br><span class="line">        <span class="keyword">return</span> deadAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_isSeparated) &#123;</span><br><span class="line">        <span class="keyword">return</span> separatedAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_isRetired) &#123;</span><br><span class="line">        <span class="keyword">return</span> retiredAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> normalPayAmount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="缘起">缘起</h2>
<p>条件表达式有两种形式。一种是检查是否正常行为。另一种是先响应正常的行为，其余的都是异常状况。</p>
<p>这些条件类型目的各异，并且会在代码中体现出来。如果都属于正常行为，用一个 <code>if-else</code>。如果是一种异常条件，检查到该异常条件为 true 后返回。第二种检查方式通常叫作 <code>Guard Clauses</code>。</p>
<p>本文标题是强调的关键点之一。如果你正在使用 <code>if-else</code> 的结构，表明赋予 <code>if</code> 和 <code>else</code> 同等的权重。传达给读者两个分支有着相同的可能性和重要性。而 <code>Guard Clauses</code> 则说：“这种情况很少见，一旦出现，得处理一下才能离开。”</p>
<p>在与遵循方法只有一个入口一个出口的程序员合作时，我通常要用 <code>Guard Clauses</code> 替换他的嵌套条件。一个入口是由现代语言强制要求的，而一个出口则不是一条有用规则。关键是要谨记：如果一个出口能使方法更清晰，用之，否则不用。</p>
<h2 id="过程">过程</h2>
<ul>
<li><p>把每个检查放到 <code>Guard Clauses</code>。</p>
<blockquote>
<p><code>Guard Clauses</code> 要么返回，要么抛异常。</p>
</blockquote></li>
<li><p>替换为 <code>Guard Clauses</code> 之后要编译和测试。</p>
<blockquote>
<p>如果所有 <code>Guard Clauses</code> 产出同样的结果，合并条件表达式。</p>
</blockquote></li>
</ul>
<h2 id="示例">示例</h2>
<p>假设有一个对死亡、离职和退休员工有特殊规则的薪酬系统，这些都是不寻常的情况，但时有发生。</p>
<p>如果我看到这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPayAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">if</span> (_isDead) &#123;</span><br><span class="line">        result = deadAmount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_isSeparated) &#123;</span><br><span class="line">            result = separatedAmount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_isRetired) &#123;</span><br><span class="line">                result = retiredAmount();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result = normalPayAmount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种校验会掩盖正常的行为。因此换成 <code>Guard Clauses</code> 更清晰。我可以逐个引入，先由最上面的开始：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPayAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_isDead) &#123;</span><br><span class="line">        <span class="keyword">return</span> deadAmount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_isSeparated) &#123;</span><br><span class="line">        result = separatedAmount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_isRetired) &#123;</span><br><span class="line">            result = retiredAmount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            result = normalPayAmount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续替换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPayAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_isDead) &#123;</span><br><span class="line">        <span class="keyword">return</span> deadAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_isSeparated) &#123;</span><br><span class="line">        <span class="keyword">return</span> separatedAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_isRetired) &#123;</span><br><span class="line">        result = retiredAmount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        result = normalPayAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPayAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_isDead) &#123;</span><br><span class="line">        <span class="keyword">return</span> deadAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_isSeparated) &#123;</span><br><span class="line">        <span class="keyword">return</span> separatedAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_isRetired) &#123;</span><br><span class="line">        <span class="keyword">return</span> retiredAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = normalPayAmount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 <code>result</code> 临时变量是多余的，可以去掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPayAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_isDead) &#123;</span><br><span class="line">        <span class="keyword">return</span> deadAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_isSeparated) &#123;</span><br><span class="line">        <span class="keyword">return</span> separatedAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_isRetired) &#123;</span><br><span class="line">        <span class="keyword">return</span> retiredAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> normalPayAmount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遵循方法只有一个出口的程序员常常写出嵌套的条件代码，我觉得这样做很傻很天真。当我对方法后面不感兴趣时，会选择马上退出。 这时出现的空 <code>else</code> 块只会令人费解。</p>
<h2 id="示例条件反转">示例：条件反转</h2>
<p>在评审本书稿时，<code>Joshua Kerievsky</code> 指出，还可以用反转条件表达式实现替换 <code>Guard Clauses</code>。他的示例让我茅塞顿开：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAdjustedCapital</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_capital &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_intRate &gt; <span class="number">0</span> &amp;&amp; _duration &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = (_income / _duration) * ADJ_FACTOR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依然是逐个替换，不过这次我反转放到 <code>Guard Clauses</code> 的条件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAdjustedCapital</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_capital &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_intRate &gt; <span class="number">0</span> &amp;&amp; _duration &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result = (_income / _duration) * ADJ_FACTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于下个条件复杂点，要分两步来反转。首先取反：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAdjustedCapital</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_capital &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(_intRate &gt; <span class="number">0</span> &amp;&amp; _duration &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = (_income / _duration) * ADJ_FACTOR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样取反的条件不易理解，所以展开简化如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAdjustedCapital</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_capital &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_intRate &lt;= <span class="number">0</span> || _duration &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = (_income / _duration) * ADJ_FACTOR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情形下我喜欢让它返回明确的值。这样你能轻易明白 <code>Guard Clauses</code> 失败的结果（我考虑过用常量代替魔法数字）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAdjustedCapital</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_capital &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_intRate &lt;= <span class="number">0</span> || _duration &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = (_income / _duration) * ADJ_FACTOR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后移除临时变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAdjustedCapital</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_capital &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_intRate &lt;= <span class="number">0</span> || _duration &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (_income / _duration) * ADJ_FACTOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>嵌套的条件判断会导致方法的正常执行路径不明晰，使代码可读性下降。本文提供一种对嵌套条件重构的方法，能有效提升代码的可读性。</p>
<p>原文：<a href="http://sourcemaking.com/refactoring/replace-nested-conditional-with-guard-clauses" class="uri">http://sourcemaking.com/refactoring/replace-nested-conditional-with-guard-clauses</a></p>
<p>条件判断会导致方法的正常执行路径不明晰。</p>
<p>特例一概使用 <code>Guard Clauses</code>。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://efe.baidu.com/tags/JavaScript/"/>
    
      <category term="重构" scheme="http://efe.baidu.com/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 Javascript 中实现调用父类同名方法的语法糖(this._super())]]></title>
    <link href="http://efe.baidu.com/blog/oo-super-syntax-in-javascript/"/>
    <id>http://efe.baidu.com/blog/oo-super-syntax-in-javascript/</id>
    <published>2015-03-01T16:00:00.000Z</published>
    <updated>2015-03-02T06:04:32.000Z</updated>
    <content type="html"><![CDATA[<p>在很多 OO 的语言中，都提供了某种便捷的语法糖去调用基类中被子类覆盖的方法，比如在 Java 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"A"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.method();</span><br><span class="line">        System.out.println(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Python 中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">  def method():</span><br><span class="line">    print('A')</span><br><span class="line"></span><br><span class="line">class B(A)</span><br><span class="line">  def method():</span><br><span class="line">    super(B, self).method()</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure>
<p>这种调用方式的好处在于：基类名称变化后，子类不用多处的修改，同时语义也比直接引用父类方法更加清晰。</p>
<p>在 JS 中，我设想了以下方式的语法调用：</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">A.prototype.method = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'A#method'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">B.prototype.method = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._super(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'B#method'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inherits(B, A);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.method(); <span class="comment">// 打印出: A#method B#method</span></span><br></pre></td></tr></table></figure>
<p>本质就是inherits的实现，因为 super 为关键字，所以使用了_super 代替。</p>
<h2 id="实现方案1---字符串匹配_super关键字动态改写">实现方案(1) - 字符串匹配_super关键字，动态改写</h2>
<p>John Resig 在他的<a href="http://ejohn.org/blog/simple-javascript-inheritance/" target="_blank" rel="external">博文</a> 使用了该方案实现了 super 语法糖。</p>
<p>主要原理为：获取方法的代码字符串，通过正则检测字符串中是否包含 <code>_super</code> ，若包含， 则改写该方法，在改写的方法中动态的改变this._super，使其指向父类同名方法，以完成调用父类方法的目的。代码可参考上面给出的文章链接。</p>
<p>这种实现方案的问题在于：</p>
<ol style="list-style-type: decimal">
<li>改写了原有方法，使得调试起来具有很大迷惑性；</li>
<li>极端的场景可能会出问题，如字符串中出现个 <code>_super</code>。</li>
</ol>
<h2 id="实现方案2---通过arguments.callee.caller查找调用方法名再进行父类方法调用">实现方案(2) - 通过arguments.callee.caller查找调用方法名，再进行父类方法调用</h2>
<p>简单的实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _super = <span class="function"><span class="keyword">function</span> <span class="params">(args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> method = <span class="keyword">this</span>._super.caller;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!method) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"Cannot call _super outside!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name = method.__name__;</span><br><span class="line">    <span class="keyword">var</span> superCls = method.__owner__._superClass;</span><br><span class="line">    <span class="keyword">var</span> superMethod = superCls[name];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> superMethod !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"Call the super class's "</span> + name + <span class="string">", but it is not a function!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> superMethod.apply(<span class="keyword">this</span>, args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inherits = <span class="function"><span class="keyword">function</span> <span class="params">(SubCls, SuperCls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> SuperCls !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        SuperCls = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> overrides = SubCls.prototype;</span><br><span class="line">    <span class="keyword">var</span> superPro = SuperCls.prototype;</span><br><span class="line"></span><br><span class="line">    fn.prototype = superPro;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> subPro = SubCls.prototype = <span class="keyword">new</span> fn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> overrides) &#123;</span><br><span class="line">        <span class="keyword">var</span> v = overrides[k];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> v === <span class="string">'function'</span>) &#123;</span><br><span class="line">            v.__name__ = k;</span><br><span class="line">            v.__owner__ = subPro;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        subPro[k] = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    subPro.constructor = SubCls;</span><br><span class="line">    subPro._superClass = superPro;</span><br><span class="line">    subPro._super = _super;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码主要通过 _super 函数和 inherits 函数实现了调用基类方法的模板功能。</p>
<p>inherits 函数主要的功能有两个:</p>
<ol style="list-style-type: decimal">
<li>实现了基本的继承</li>
<li>对原型函数附加了 <code>__name__</code> 和 <code>__owner__</code> 属性。前者是为了提供对_super的支持，方便其找到函数名，后者是为了在多级继承的时候，跳出作用域的死循环。</li>
</ol>
<p>_super 流程如下：</p>
<ol style="list-style-type: decimal">
<li>找 caller</li>
<li>获取caller的函数名<code>__name__</code></li>
<li>获取 caller 的拥有者<code>__owner__</code></li>
<li>找到<code>__owner__</code>的父类</li>
<li>调用同名函数</li>
</ol>
<p>方案二的缺点：</p>
<ol style="list-style-type: decimal">
<li>无法用在严格模式下</li>
<li>会给函数额外增加自定义的属性(<code>__name__</code>与<code>__owner__</code>)</li>
</ol>
<h2 id="综合考虑">综合考虑</h2>
<p>在我们的<a href="https://github.com/ecomfe/oo" target="_blank" rel="external">oo库</a>中，最后选用的是方案二，主要权衡为：</p>
<ol style="list-style-type: decimal">
<li>严格模式带来的缺陷避免收益完全可以由工具(ide, jshint..)取代，我们每次提交代码前都会经过 jshint 的代码检测，因此不使用严格模式对我们来说没有什么影响。</li>
<li>在实际的编码过程中，基本是不会出现和自定义属性出现重名的场景，这也算是一个约定。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>在很多 OO 的语言中，都提供了某种便捷的语法糖去调用基类中被子类覆盖的方法，比如在 Java 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"A"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.method();</span><br><span class="line">        System.out.println(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Python 中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">  def method():</span><br><span class="line">    print('A')</span><br><span class="line"></span><br><span class="line">class B(A)</span><br><span class="line">  def method():</span><br><span class="line">    super(B, self).method()</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure>
<p>这种调用方式的好处在于：基类名称变化后，子类不用多处的修改，同时语义也比直接引用父类方法更加清晰。</p>
<p>在 JS 中，我设想了以下方式的语法调用：</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://efe.baidu.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PC端大型单页式商业内容管理系统的JS模块化构建探索]]></title>
    <link href="http://efe.baidu.com/blog/pc-spa-js-build/"/>
    <id>http://efe.baidu.com/blog/pc-spa-js-build/</id>
    <published>2015-02-12T16:00:00.000Z</published>
    <updated>2015-02-13T01:51:18.000Z</updated>
    <content type="html"><![CDATA[<h3 id="前提">前提</h3>
<p>为了不被喷得太惨，给标题加了这么多的限制定语也是相当不容易的了。此文讨论的是我所处的环境下对JavaScript构建的一些简单探索，因此有相当多的前提限制。</p>
<p>首先，何为大型。从我们的系统来看，20多个业务模块，近100个页面组成的单页系统，对应的业务源码代码量如下：</p>
<div class="figure">
<img src="/blog/pc-spa-js-build/src.png">
</div>
<a id="more"></a>
<p>对应的依赖库，除<code>underscore</code>和<code>moment</code>外均为公司内部库，代码量为：</p>
<div class="figure">
<img src="/blog/pc-spa-js-build/dep.png">
</div>
<p>其次，所谓的“模块化”指我们使用AMD进行构建，使用符合社区AMD标准的Loader进行模块的加载。</p>
<p>而“PC 端单页式商业内容管理系统”则代表着系统的不少特性：</p>
<ul>
<li>使用是相对强制的，对用户来说这是一项工作，而不是爱用不用的用户产品。</li>
<li>商业公司通常拥有较好的网络环境，面向PC设计更使得带宽不是一个需要着重考虑的因素。</li>
<li>单页系统使得所有功能被包含在一个HTML页面内，不存在页间的跳转，因此资源不以页面为单位进行切分。</li>
</ul>
<h3 id="为何要构建">为何要构建</h3>
<p>第一个问题是，AMD有自然的按需加载的属性，按需加载也是一直被提倡的一种模式。那么，如果不进行任何的构建，让模块自然地按需加载，是否可行？</p>
<p>如果看了这个图，你还相信按需加载的话，可以停止此文的阅读了：</p>
<div class="figure">
<img src="/blog/pc-spa-js-build/requests.png">
</div>
<p>简单来说，按需加载与构建并不冲突，我们不能将所有资源最细粒度地使用按需加载进行管理，必要的构建来减少资源请求是必要的。</p>
<p>随之而来的，我们会考虑标准的代码合并方案。相当多的站点会将所有的JavaScript合并为一个文件，这也是最简单粗暴有效的方案。</p>
<p>但是对于大型的单页系统而言，所有JavaScript合并后生成的文件会非常之巨大，其体积在浏览器单线程的下载模式下已经成为系统的性能瓶颈。因此我们需要一些更好的策略，让系统的启动性能得以优化。</p>
<p>最后，常用于业界的还有一种方案，即自动化的运行时合并。通过在服务器端配置一个处理程序，可以运行时检测需要文件的依赖，进行依赖打包并响应至客户端。</p>
<p>这种方案有其成本小、透明化等多方面的优势，但在精益求精的场景下仍旧略有不足。其最大的缺点是当有2个以上模块依赖同一个模块时，被依赖模块可能会被重复打包到多份<code>.js</code>文件中，造成不必要的网络传输。</p>
<p>当然有很多的方法解决这一问题，诸如在Session中记录用户已经拥有的模块，或由客户端记录并提供已有模块列表，来保证打包过程不会加入无用的模块。但这些方法会提升一定的开发成本，同时前后端合作才可以完成的方案往往在推进上会遇到一些小阻碍。</p>
<p>基于这些原因，从前端静态化的构建入手，在构建阶段实现较为优化的打包方案，是现阶段我们采取的策略。</p>
<h3 id="准则">准则</h3>
<p>从系统运行时来分析，对于JavaScript的构建，可以提出以下的原则。</p>
<h4 id="控制请求段的数量">控制请求段的数量</h4>
<p>“请求段”是一个很模糊的概念，简单来说，在一个带宽足够的环境下，我们并不看重运行时产生了多少个请求，而是看重这些请求在瀑布图中被分为几段。由于浏览器并行加载的特性，系统真正的可用时间是由段的数量和每一个段的时间来决定的。</p>
<p>对于常见的浏览器，其并行加载的请求个数为4-6个，也即一个段可以加入4-6个的请求。从分段越少越好的角度来考虑，我们规划的系统启动分为3个段：</p>
<ol style="list-style-type: decimal">
<li>加载必要的前置条件，其中最为主要的是AMD Loader。<code>.css</code>文件可以在这个阶段加载，以避免影响后面更重量级的<code>.js</code>的加载效率。</li>
<li>主要的JavaScript模块的加载，在此段通过对并行数的控制，期望在一个段内加载完所有必要的模块。同时从<code>段的用时 = 段内加载总大小 / 并发数</code>这一公式考虑，应尽可能将模块打包为浏览器可接受的最大并发数个文件。</li>
<li>一些动态的信息，如用户登录信息、系统常量表等，这些信息是易变或动态的，因此从缓存的角度考虑不适合进行打包。</li>
</ol>
<p>从我们的系统来看，仅看JavaScript的资源，很明显地分为3段进行加载（红线分隔）：</p>
<div class="figure">
<img src="/blog/pc-spa-js-build/http-block.png">
</div>
<h4 id="文件大小">文件大小</h4>
<p>从经验值来看，单个资源的大小尽量控制在未Gzip前500KB以内，过大的文件会成为瓶颈，除非你可以很好地规划一个HTTP请求段，使得一个大文件加载的用时内浏览器会利用另一个TCP链接加载多个小文件。</p>
<p>Gzip对纯文本文件的压缩率一般在16%左右，文件的形式和内容不会对此比率造成特别大的影响。如果使用Linux或OSX系统，可以简单地使用以下命令来看一个文件Gzip后的近似大小：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -c &#123;file&#125; | wc -c</span><br></pre></td></tr></table></figure>
<p>同时，由于短板效应的存在，一个段的加载时间会由这个段内最大的资源决定，因此尽量使得各资源的大小相近。</p>
<h4 id="请求控制">请求控制</h4>
<p>并不是所有的文件都需要合并在一起，也不是所有资源都可以按需加载，对于请求数量的控制并不仅仅体现在系统启动时，也贯穿整个系统的使用流程，来提供用户一致的性能体验。</p>
<p>我对一个大型CMS系统的请求数量的总结可以概括为3点：</p>
<ol style="list-style-type: decimal">
<li>在导航通过一次操作可到达的页面内，不应该产生额外的请求，即系统启动过程中这些模块都应当就位。</li>
<li>在一级页面中进行下探才可以到达的页面，尽量控制一个页面仅产生一个请求。考虑到单个页面的资源不会很大，因此再行拆分并行加载反而可能因为TCP链接、网络延迟等因素有负面的效果。</li>
<li>对于特别大的页面，或者页面中一定条件下才会访问的区域，相关资源使用按需加载的策略配置。</li>
</ol>
<p>基于以上的这些原则，我在系统中有进一步的实践。</p>
<h3 id="实践">实践</h3>
<h4 id="文件合并">文件合并</h4>
<p>将JavaScript文件分为多个“启动脚本”，一个启动脚本中会包含一系列的模块，现有系统中我将启动脚本分割为4个，分别为：</p>
<ol style="list-style-type: decimal">
<li>特别大的库单独拥有自己的一个脚本，比如<code>ECharts</code>之类的图表库。</li>
<li>UI控件库，包含基础UI控件和业务UI控件，合并为一个脚本。</li>
<li>MVC框架、页面基类、工具类、系统通用功能层等业务无关的逻辑合并为一个脚本。</li>
<li>一级页面的业务模块合并为一个脚本。</li>
</ol>
<p>需要特别注意的是，各启动脚本间应该保持完美的正交，即不应该有任何一个模块被重复合并到多个脚本中。</p>
<p>除了启动脚本外，前面也有提到单一页面应该尽可能只加载一个资源，因此页面相关会被打包在一起，比较典型的是将Controller、Model和View合并到Controller对应的文件中。</p>
<p>由于二级页面并不能确定哪一个会被先访问，因此各页面打包文件中是会存在一定的模块重复的，经典如<code>util</code>模块就会同时被列表、表单、只读等页使用。这会导致加载多个页面时部分资源被重复加载，但是此类资源通常体积很小，产生的副作用在可控范围内。</p>
<h4 id="文件加载">文件加载</h4>
<p>在文件加载这一方向上，需要有一个特别的处理。由于AMD的依赖管理和运行时依赖分析功能，通过Loader的<code>require</code>函数加载一个模块的化，Loader会自动分析依赖并通过零碎的HTTP请求去请求相关的资源，而无视这些资源是否可能被下一个脚本打包在一起。</p>
<p>用一个实例来说明，我们的依赖关系为<code>a -&gt; b</code>以及<code>c -&gt; b</code>，即<code>b</code>模块是一个通用模块，被两边所依赖。当我们将<code>a</code>和<code>c</code>分开打包为2个文件时，<code>b</code>会出现在其中一个中（为了实现完美正交）。假设<code>b</code>被打包在<code>a.js</code>中，那么当<code>c.js</code>被Loader加载时，如果<code>a.js</code>还未就位，就会产生一个单独的HTTP请求<code>b.js</code>。由于并行下载时，谁先完成是不可预知的，就有很大的可能性产生无意义的零碎请求。</p>
<p>解决这一问题的方法是，使用<code>&lt;script&gt;</code>标签来引入这些打过包的脚本，而不要让Loader去做加载。由于<code>&lt;script&gt;</code>标签的执行过程中并不会有依赖分析，也就不会产生额外的请求。</p>
<p>需要注意的是，能够使用<code>&lt;script&gt;</code>标签来实现这一功能，需要对应的Loader有延迟执行AMD模块的<code>factory</code>函数的功能，即遵循CMD规范。现有业界<code>RequireJS</code>和百度的<code>esl</code>都有这一功能，可放心使用。</p>
<h4 id="硬编码预加载">硬编码预加载</h4>
<p>除去打包这一比较常规的步骤之上的微创新外，前端在资源加载方向上还有一个很重要的方向就是“预加载”。所谓预加载，即在用户尚未使用某一个功能的时候预先加载相关的资源并缓存，便于用户使用时能够快速获得资源。预加载的探索上，有几个指标至关重要：</p>
<ol style="list-style-type: decimal">
<li>加载的时机。在保证用户需要时已经加载完毕的前提下，越晚加载越有利于系统整体的性能。</li>
<li>加载的精度。预加载一个用户最终都没有用到的资源是一种浪费的行为。</li>
</ol>
<p>从这两点出发，预加载可以衍生出相当多的子话题，包括：</p>
<ol style="list-style-type: decimal">
<li>用户行为预测，如用户停留在某一个列表页面时时，根据其以往的行为进行分析，很有可能进入新建的操作。</li>
<li>临近加载，如计算用户的鼠标轨迹来预测后续可能点击的按钮等。</li>
<li>空闲加载，通过统一的请求管理，寻找网络空闲的时候来加载需要的资源，从而不影响急需的资源的加载进度。</li>
</ol>
<p>由于在这一块还没有深入的探索和相关的产出，因此不再赘述。</p>
<h4 id="版本管理">版本管理</h4>
<p>在构建完成后，由于HTTP缓存的特性，我们希望可以达到静态资源永久缓存的前提下又可以准确地进行缓存过期。在这一方向上，最为普遍的方法即使用一定的算法为资源生成版本号，从而使得新旧资源的URL不同，来强制浏览器加载新的资源。</p>
<p>在版本号的算法选择中，MD5大致是当前最优的方案。但由于MD5的计算和HTML中资源链接的替换都相对成本较高，在某种情况下使用简单的递增或SVN Revision作为版本号都是可以考虑的。这些相关的话题都有过很深入的讨论，也不作为本文详细描述的重点。</p>
<p>在版本号控制缓存的规划之中，需要注意的是对脚本的“变化频率”进行预测，我们应当尽可能地将下次变化时间相同/相近的资源打包在一起，以避免因为一个资源变化导致大量资源要同时失去缓存的场景出现。</p>
<p>在这种控制上，简单的策略有2种：</p>
<ol style="list-style-type: decimal">
<li>通过分层设计，将系统自下而上，自基础至业务分为多层，越接近下层（基础）的代码变动理应越少，而越接近上层（业务）的代码则理应有更频繁的变动。通过分层可以简单地区分这些，上文提到的脚本分割策略也一定程度上基于这一理论。</li>
<li>对于易变的内容，可以进一步通过策略等模式，抽取出不变和可变的部分，将可变的部分打包在一起的同时，提供一些接口来允许覆盖这些“可变量”。随后通过一种“灰度脚本”，即临时性执行的脚本来覆盖这些可变量，达到在一定时期内运行新的策略，但不至于打包的脚本缓存过期的目的。当打包脚本确实需要过期时，则再将新策略内联到脚本中。</li>
</ol>
<h3 id="总结">总结</h3>
<p>由于系统的私有性，以及我们团队使用的工具相对并不流行，因此本文也不再放出实例代码来了。</p>
<p>以上是我在系统中进行的构建相关的初步探索，得到的只是一个<strong>静态</strong>的<strong>简单</strong>的构建模型，远未达到我预期中的最佳。</p>
<p>至于最佳的构建会是怎么样的，考虑到我还想用这些产出去升个职什么的，便不再透露了，等到实际有了成果后再总结成文共享。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="前提">前提</h3>
<p>为了不被喷得太惨，给标题加了这么多的限制定语也是相当不容易的了。此文讨论的是我所处的环境下对JavaScript构建的一些简单探索，因此有相当多的前提限制。</p>
<p>首先，何为大型。从我们的系统来看，20多个业务模块，近100个页面组成的单页系统，对应的业务源码代码量如下：</p>
<div class="figure">
<img src="/blog/pc-spa-js-build/src.png" />
</div>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://efe.baidu.com/tags/JavaScript/"/>
    
      <category term="SPA" scheme="http://efe.baidu.com/tags/SPA/"/>
    
      <category term="构建" scheme="http://efe.baidu.com/tags/%E6%9E%84%E5%BB%BA/"/>
    
      <category term="模块化" scheme="http://efe.baidu.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ESL 发布 2.0]]></title>
    <link href="http://efe.baidu.com/blog/esl-2.0/"/>
    <id>http://efe.baidu.com/blog/esl-2.0/</id>
    <published>2015-02-05T16:00:00.000Z</published>
    <updated>2015-02-06T03:58:40.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/ecomfe/esl" target="_blank" rel="external">ESL</a> 是一个<code>浏览器端</code>、<code>符合AMD</code>的标准加载器，适合用于现代Web浏览器端应用的入口与模块管理。</p>
<p>通过<code>右键另存</code>的方式可以下载ESL:</p>
<ul>
<li><a href="http://s1.bdstatic.com/r/www/cache/ecom/esl/2-0-4/esl.js" target="_blank" rel="external">压缩代码 (Compressed)</a></li>
<li><a href="http://s1.bdstatic.com/r/www/cache/ecom/esl/2-0-4/esl.source.js" target="_blank" rel="external">源码 (Source)</a></li>
</ul>
<p>今天，ESL release 了 2.0.4。到这里本应该完了，不过好像内容少了点。为了凑数，还是多扯几句吧：</p>
<a id="more"></a>
<h3 id="为什么使用esl而不用requirejs">为什么使用ESL而不用RequireJS</h3>
<p>很官方的答案是，ESL比RequireJS：</p>
<ul>
<li>体积更小 (Smaller)</li>
<li>性能更高 (Higher performance)</li>
<li>更健壮 (More Robustness)</li>
<li>不支持在<code>非浏览器端</code>使用 (Browser only)</li>
<li>依赖模块<code>用时定义</code> (Lazy define)</li>
</ul>
<p>作为ESL的主要开发者，我个人的答案是：</p>
<ol style="list-style-type: decimal">
<li>上面的吹牛都不是吹牛，都是真的。</li>
<li>蚊子再小也是肉，有更小性能更高的干嘛不用？</li>
<li>反正换个Loader没成本的咯，就改个script的src，分分钟的事。不行再换回来也是分分钟的事。只有选Framework选对象这种事情，选错了替换成本才会比较高。</li>
</ol>
<p>诚信是做人之本，欺瞒消费者是令人痛恨的行为。所以在这里要说一下：RequireJS提供了一些非AMD标准的功能，比如<code>data-main</code>、比如可以直接require一个url。ESL是不支持的。如果你用到这些功能，并且觉得这些功能很有用的话，还是不要换了。</p>
<h3 id="x和1.x相比是breaking-change吗">2.x和1.x相比是breaking change吗</h3>
<p>有的ESL 1.x的使用者，一看到第一位版本号加了，是不敢升级的。在common sense里，第一位版本号的增加代表的是breaking change。但是，ESL本身是个AMD Loader啊，breaking change难道就不是AMD了么？显然ESL不敢这么玩。</p>
<p>真实情况是这样的：我们完成了对<code>shim</code>的支持。ESL已经做到AMD特征完备了。这也算是个里程碑吧。所以，这一次我们跳到了2.x。</p>
<h3 id="为什么发布2.0是2.0.4而不是2.0.0">为什么发布2.0是2.0.4而不是2.0.0</h3>
<p>大约1个月前，我们就已经release 2.0.0。虽然有完善的测试用例做支撑，但我们觉得，万事无绝对。所以我们在一些Baidu的产品线中先使用验证，这些产品线的业务场景都比较复杂。验证过程中还真发现一个在包含resource的复杂场景下和加载过程有关的bug: <a href="https://github.com/ecomfe/esl/issues/35" target="_blank" rel="external">issue35</a></p>
<p>现在我们觉得，应该比较稳定了，所以在blog上发出来，给出一个交代。</p>
<p>但是，下面这个理由应该更可信一点：快过年了，大家都歇了，没人写blog，只能发这种东西来凑数了。</p>
<h3 id="下载下来用还是直接使用esl提供的cdn">下载下来用？还是直接使用ESL提供的CDN？</h3>
<p>先看看ESL提供的CDN引用地址：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- compressed --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://s1.bdstatic.com/r/www/cache/ecom/esl/2-0-4/esl.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- source --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://s1.bdstatic.com/r/www/cache/ecom/esl/2-0-4/esl.source.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一看这个URL就很山寨，有没有？有没有？？？？为了让大家放心使用，在这里偷偷爆尿下，我们很多在Baidu搜索结果页面上的资源就是用的这个CDN，稳定性很高。</p>
<p>当然，下载使用还是CDN使用本来就是开发者的偏好，大家自己决定。这里只是想提一句，我们提供的CDN引用是稳定有诚意的，不是坑爹的。</p>
<h3 id="最后">最后</h3>
<p>如果你开发中还是各种手工引入JS，那么，建议你使用AMD的方式开发。我们不能总是活在原始社会。</p>
<p>如果你已经在用SeaJS，在已有项目中也没必要换到AMD来，虽然AMD应用面更广泛一些。</p>
<p>如果你想更深入了解AMD，可以看看我之前写的几篇写到吐血、写到今年都不想再写了的blog。内容比较长，很能考验读者的耐心。其中，第三篇的一些内容，已经过时了：</p>
<ul>
<li><a href="http://efe.baidu.com/blog/dissecting-amd-what/" target="_blank" rel="external">玩转AMD系列 - 设计思路篇</a></li>
<li><a href="http://efe.baidu.com/blog/dissecting-amd-how/" target="_blank" rel="external">玩转AMD系列 - 应用实践篇</a></li>
<li><a href="http://efe.baidu.com/blog/dissecting-amd-loader/" target="_blank" rel="external">玩转AMD系列 - Loader篇</a></li>
</ul>
<p>如果你觉得我们还算有诚意，给个star支持下呗，反正不花钱。</p>
<iframe src="https://ghbtns.com/github-btn.html?user=ecomfe&amp;repo=esl&amp;type=star&amp;count=true" frameborder="0" scrolling="0" width="170px" height="20px">
</iframe>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/ecomfe/esl">ESL</a> 是一个<code>浏览器端</code>、<code>符合AMD</code>的标准加载器，适合用于现代Web浏览器端应用的入口与模块管理。</p>
<p>通过<code>右键另存</code>的方式可以下载ESL:</p>
<ul>
<li><a href="http://s1.bdstatic.com/r/www/cache/ecom/esl/2-0-4/esl.js">压缩代码 (Compressed)</a></li>
<li><a href="http://s1.bdstatic.com/r/www/cache/ecom/esl/2-0-4/esl.source.js">源码 (Source)</a></li>
</ul>
<p>今天，ESL release 了 2.0.4。到这里本应该完了，不过好像内容少了点。为了凑数，还是多扯几句吧：</p>]]>
    
    </summary>
    
      <category term="AMD" scheme="http://efe.baidu.com/tags/AMD/"/>
    
      <category term="ESL" scheme="http://efe.baidu.com/tags/ESL/"/>
    
      <category term="JavaScript" scheme="http://efe.baidu.com/tags/JavaScript/"/>
    
      <category term="模块化" scheme="http://efe.baidu.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ECharts-X 发布 0.1]]></title>
    <link href="http://efe.baidu.com/blog/echarts-x-0.1/"/>
    <id>http://efe.baidu.com/blog/echarts-x-0.1/</id>
    <published>2015-02-03T16:00:00.000Z</published>
    <updated>2015-05-05T00:11:06.000Z</updated>
    <content type="html"><![CDATA[<p>ECharts-X 发布啦！3D 的 Glob Visualization，3D 的 markPoint， markLine，艺术的风场洋流可视化，一切都有可能！ECharts the next generation ！好奇的小伙伴们快去<a href="http://echarts.baidu.com/x/doc/index.html" target="_blank" rel="external">官网</a>看看吧！</p>
<div class="figure">
<img src="/blog/echarts-x-0.1/banner.jpg" alt="ECharts-X"><p class="caption">ECharts-X</p>
</div>
<a id="more"></a>
<p><a href="http://echarts.baidu.com/" target="_blank" rel="external">ECharts</a>，缩写来自 Enterprise Charts，开源的商业级数据图表库，来自百度EFE数据可视化团队。相信一直关注大数据，特别是关注数据可视化的朋友对 ECharts 已经并不陌生了，据最近的一份中国 Github 年度报告里的统计显示，ECharts 已经成为了 Github上Star 数最多的中国开源项目，也是Github Explorer Data Visualization 板块上第一个也是目前唯一一个来自中国的开源项目，在这样一个精专的领域内近6000的star已经足以说明这条小鲸鱼的影响力。而且不仅是在国内， ECharts 还受到了国外技术团队，领域专家们的关注，ECharts Datamatic Edition（英文版的百度图说）的出现，twitter、Hacker news、 Medium Daily Digest 等媒体上也越来越多的看到ECharts的影子。</p>
<p>2013年6月30日发布1.0以来，1年多时间来 ECharts 已经迭代发布了20多个版本，就在一周前（1月30号）ECharts 发布了最新的2.2.0的同时低调的给大家带来了第一个官方分支版本 ECharts-M ( ECharts Mobile )，这是一个针对移动设备设备的优化版本，大家可以扫描页面下方的二维码在移动设备上体验到这个版本。移动版是大家期待已久的版本，如此低调的发布了这样一个重要的版本多少让人有点好奇，ECharts 团队在酝酿什么？</p>
<p><strong>ECharts-X Next Generation of ECharts</strong></p>
<p>这是3D（WebGL）版的 ECharts，这是由 ECharts 团队核心主创 <a href="http://weibo.com/pissang" target="_blank" rel="external">沈毅</a> 主导的项目，用 <a href="http://weibo.com/u/1808084593" target="_blank" rel="external">林峰</a> 的原话来说“这代表着 ECharts 团队最高的技术水平也代表着 ECharts 的未来，无限的可能。”</p>
<p>据项目负责人沈毅透露，ECharts-X 应该很快就能跟大家见面了，她将会有的一些特性：</p>
<ul>
<li>跟 ECharts 的无缝集成，能够使用 ECharts 里的所有组件，能够跟折柱饼地图等混搭，配置项也是 ECharts 的风格，熟悉的配方熟悉的味道。</li>
<li>目前只支持 Globe Visualization，即 map3d，可以使用 ECharts map 中相同的 markPoint（标点）, markLine（标线）, 还有新加的 markBar（标柱）, 这个大家看到应该也不会陌生，three.js 里就有一个很经典的 webgl-globe 项目实现了这个效果。</li>
<li>风场，洋流等向量场的可视化，这个借鉴了之前 NASA 非常有名的洋流表层可视化，之前去浙大交流的时候也在陈为老师的实验室看到他们也做类似的可视化工作，ECharts-X 也将具备这样的能力。</li>
</ul>
<p>尽管现在还只是 0.1 版本，可能还有些功能缺失，新加入的图表类型也只有 map3d（地图），也可能会有些不可原谅的bug，但是对于 ECharts-X 的发展我们从没有如此清晰和坚定过，短期的未来就会有scatter3d（散点）、surface3d（曲面图），期待大家的关注。作为 the next generation of ECharts，相信能够为 ECharts 的可视化带来更多的可能性。” – by <a href="http://weibo.com/pissang" target="_blank" rel="external">沈毅</a>。</p>
<hr>
<p>无图无真相，大家过过瘾吧：</p>
<div class="figure">
<img src="/blog/echarts-x-0.1/mark-point.gif" alt="MarkPoint 标点，炫光特效"><p class="caption">MarkPoint 标点，炫光特效</p>
</div>
<div class="figure">
<img src="/blog/echarts-x-0.1/mark-line.gif" alt="MarkLine 标线，炫光特效"><p class="caption">MarkLine 标线，炫光特效</p>
</div>
<div class="figure">
<img src="/blog/echarts-x-0.1/mark-bar.gif" alt="MarkBar 标柱、栅格"><p class="caption">MarkBar 标柱、栅格</p>
</div>
<div class="figure">
<img src="/blog/echarts-x-0.1/surface.gif" alt="洋流向量场可视化"><p class="caption">洋流向量场可视化</p>
</div>
<p>虽然只是截图跟运行时的效果无法比，但相信已经十分惊艳了。 手机是跑不起X了，不够过瘾的话扫扫看看ECharts-M。</p>
<div class="figure">
<img src="/blog/echarts-x-0.1/echarts-m.png" alt="ECharts-M"><p class="caption">ECharts-M</p>
</div>
]]></content>
    <summary type="html">
    <![CDATA[<p>ECharts-X 发布啦！3D 的 Glob Visualization，3D 的 markPoint， markLine，艺术的风场洋流可视化，一切都有可能！ECharts the next generation ！好奇的小伙伴们快去<a href="http://echarts.baidu.com/x/doc/index.html">官网</a>看看吧！</p>
<div class="figure">
<img src="/blog/echarts-x-0.1/banner.jpg" alt="ECharts-X" /><p class="caption">ECharts-X</p>
</div>]]>
    
    </summary>
    
      <category term="3D" scheme="http://efe.baidu.com/tags/3D/"/>
    
      <category term="ECharts" scheme="http://efe.baidu.com/tags/ECharts/"/>
    
      <category term="ECharts-X" scheme="http://efe.baidu.com/tags/ECharts-X/"/>
    
      <category term="数据可视化" scheme="http://efe.baidu.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用逼近算法生成韦恩图的探究与经验]]></title>
    <link href="http://efe.baidu.com/blog/venn/"/>
    <id>http://efe.baidu.com/blog/venn/</id>
    <published>2015-01-26T16:00:00.000Z</published>
    <updated>2015-05-05T00:19:34.000Z</updated>
    <content type="html"><![CDATA[<p>维恩图（venn），也叫文氏图，用于显示元素集合重叠区域的图示。我们准备在echarts中提供这类图表。第一期支持两个集合的韦恩图，后期准备支持三个集合乃至多个集合的韦恩图</p>
<h3 id="准备">准备</h3>
<p>使用zrender框架，画出两个circle使之重叠，即可产生一个韦恩图。但是，互相重叠的部分会相互遮挡，（如下图）解决方案是对每个circle都调整透明度至50%。</p>
<div class="figure">
<img src="/blog/venn/img/opacity.png" alt="venn 透明度"><p class="caption">venn 透明度</p>
</div>
<a id="more"></a>
<h3 id="确定位置">确定位置</h3>
<p>下面最困难的就是在确定一个圆的位置的情况下，根据两个集合的大小与交集的大小，确定第二个圆的位置。对于这一点，我进行了几个尝试。</p>
<h4 id="尝试一估值">尝试一————估值</h4>
<p>由于韦恩图本身可以看做一个非精确图标。所以，猜测了一个值。即两个圆心的距离的表达式是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coincideLengthAnchor = ((r0 + r1) / <span class="number">2</span>) * <span class="built_in">Math</span>.sqrt(data[<span class="number">2</span>].value) / <span class="built_in">Math</span>.sqrt((data[<span class="number">0</span>].value + data[<span class="number">1</span>].value) / <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>两个圆心的距离与两圆半径均值之比等于交集与两集合均值的开方之比。 但我们知道，同等半径、边长等情况下，圆的面积最大。所以这种方法计算的距离是偏小的，公共面积是偏大的。 而且当一个集合为另一个的子集时，误差过大。（如下图）</p>
<div class="figure">
<img src="/blog/venn/img/guess.png" alt="venn 子集不精确"><p class="caption">venn 子集不精确</p>
</div>
<h4 id="尝试二计算">尝试二————计算</h4>
<p>既然估计是不可行的，那么我就采取计算的方法。凭借我深（xue）厚（zha）的数学功底，应该能算出来圆心的距离。 省略1w字。 然后我确定我是计算不出来的。此方法也是不可行的。</p>
<h4 id="尝试三逼近算法">尝试三————逼近算法</h4>
<p>在网上进行了一系列的调研，我发现在尝试二中，我犯了一个计算机专业大一学渣都不应该犯的一个错误。就是一直使用高中数学的思维来解决问题，而没有用计算机思维。所谓计算机思维我认为核心有两点：</p>
<ol style="list-style-type: decimal">
<li>计算机性能优越，可以短时间计算大规模的数据</li>
<li>计算机允许计算无数次（递归思想）</li>
</ol>
<p>所以调研发现，诸如d3等支持维恩图的图表框架，都使用了逼近算法来计算。也就是带进去一个值去计算，不对了就换个值再计算一遍。</p>
<h3 id="逼近算法">逼近算法</h3>
<p>这里就是猜测一个coincideLength，代入计算出公共面积，然后与实际公共面积进行比较。在一定的可接受的精度内，得到coincideLength。否则，对coincideLength调整，递归代入，直至在一定的可接受的精度内，递归结束。</p>
<p>于是，开始编写代码。在此过程中遇到了若干问题。</p>
<h4 id="问题一对coincidelength调整调整不力">问题一————对coincideLength调整调整不力</h4>
<p>先设定一个coincideLength的锚定，coincideLengthAnchor。</p>
<p>当coincideLengthAnchor过小，需要增大时，我使用了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coincideLengthAnchor = (coincideLengthAnchor + r0 + r1) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>当coincideLengthAnchor过大，需要减小时，我使用了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coincideLengthAnchor = <span class="built_in">Math</span>.abs(coincideLengthAnchor - <span class="built_in">Math</span>.abs(r0 - r1)) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>我理解的是，距离最大值就是两圆外切也就是r0 + r1；距离最小时就是两圆内切也就是Math.abs(r0 - r1)。 想法很好。当然大牛的你们也发现问题了。这样做会造成数值抖动。最后报too much recursion算是好的。我才不会乱说我把浏览器不知道卡死了多少次呢。</p>
<p>所以要对每次的边界值做出相应的调整，这样递归函数增加两个参数，coincideLengthAnchorMin, coincideLengthAnchorMax。然后每次以二分法调整步调</p>
<p>当coincideLengthAnchor过小，下次递归的下限就是这次的锚定值，同时调整步调</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coincideLengthAnchorMin = coincideLengthAnchor;</span><br><span class="line">coincideLengthAnchor = (coincideLengthAnchor + coincideLengthAnchorMax) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>当coincideLengthAnchor过大，下次递归的上限就是这次的锚定值，同时调整步调</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coincideLengthAnchorMax = coincideLengthAnchor;</span><br><span class="line">coincideLengthAnchor = (coincideLengthAnchor + coincideLengthAnchorMin) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h4 id="问题一精度调整">问题一————精度调整</h4>
<p>上面也说到了。递归最后的coincideLength不可能百分比精确。那么我使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算的公共面积 (思路是扇形减三角形)</span></span><br><span class="line"><span class="keyword">var</span> area2 = alfa * r0 * r0 - x * r0 * <span class="built_in">Math</span>.sin(alfa) + beta * r1 * r1 - y * r1 * <span class="built_in">Math</span>.sin(beta);</span><br><span class="line"><span class="keyword">var</span> scaleAnchor = area2 / area0;</span><br><span class="line"><span class="keyword">var</span> scale = value2 / value0;</span><br><span class="line"><span class="keyword">var</span> approximateValue = <span class="built_in">Math</span>.abs(scaleAnchor / scale);</span><br></pre></td></tr></table></figure>
<p>scaleAnchor为计算的公共面积比第一个圆的面积。 scale为实际的公共面积比第一个圆的面积。 approximateValue就为精度。</p>
<p>开始时我把精度设为下限0.9上限1.1。得到的图基本正确，但是在两圆内切的特殊情况下就杯具了：</p>
<div class="figure">
<img src="/blog/venn/img/previous_low.png" alt="venn 精度过低"><p class="caption">venn 精度过低</p>
</div>
<p>那我为什么不把精度调整的特别高呢？我们知道二分法计算，“一尺之棰，日取其半，万事不竭”。精度过高，特别是数值特别大的时候，计算的速度又会特别慢。</p>
<div class="figure">
<img src="/blog/venn/img/previous_high.jpg" alt="venn 极限"><p class="caption">venn 极限</p>
</div>
<p>所以，我调整精度为下限0.999上限1.001。</p>
<h3 id="结论">结论</h3>
<p>完整递归函数： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">_getCoincideLength: <span class="function"><span class="keyword">function</span> <span class="params">(</span><br><span class="line">    value0,</span><br><span class="line">    value1,</span><br><span class="line">    value2,</span><br><span class="line">    r0,</span><br><span class="line">    r1,</span><br><span class="line">    coincideLengthAnchor,</span><br><span class="line">    coincideLengthAnchorMin,</span><br><span class="line">    coincideLengthAnchorMax</span><br><span class="line">)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算</span></span><br><span class="line">    <span class="keyword">var</span> x = (r0 * r0 - r1 * r1) / (<span class="number">2</span> * coincideLengthAnchor) + coincideLengthAnchor / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> y = coincideLengthAnchor / <span class="number">2</span> - (r0 * r0 - r1 * r1) / (<span class="number">2</span> * coincideLengthAnchor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 夹角</span></span><br><span class="line">    <span class="keyword">var</span> alfa = <span class="built_in">Math</span>.acos(x / r0);</span><br><span class="line">    <span class="keyword">var</span> beta = <span class="built_in">Math</span>.acos(y / r1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一个圆的面积</span></span><br><span class="line">    <span class="keyword">var</span> area0 = r0 * r0 * <span class="built_in">Math</span>.PI;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算的公共面积 (思路是扇形减三角形)</span></span><br><span class="line">    <span class="keyword">var</span> area2 = alfa * r0 * r0 - x * r0 * <span class="built_in">Math</span>.sin(alfa) + beta * r1 * r1 - y * r1 * <span class="built_in">Math</span>.sin(beta);</span><br><span class="line">    <span class="keyword">var</span> scaleAnchor = area2 / area0;</span><br><span class="line">    <span class="keyword">var</span> scale = value2 / value0;</span><br><span class="line">    <span class="keyword">var</span> approximateValue = <span class="built_in">Math</span>.abs(scaleAnchor / scale);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (approximateValue &gt; <span class="number">0.999</span> &amp;&amp; approximateValue &lt; <span class="number">1.001</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> coincideLengthAnchor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若是公共面积比较小，使距离减小一些，让公共面积增大</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (approximateValue &lt;= <span class="number">0.999</span>) &#123;</span><br><span class="line">        coincideLengthAnchorMax = coincideLengthAnchor;</span><br><span class="line">        <span class="comment">// 二分法计算新的步调</span></span><br><span class="line">        coincideLengthAnchor = (coincideLengthAnchor + coincideLengthAnchorMin) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若是公共面积比较大，使距离增大一些，让公共面积减小</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        coincideLengthAnchorMin = coincideLengthAnchor;</span><br><span class="line">        coincideLengthAnchor = (coincideLengthAnchor + coincideLengthAnchorMax) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._getCoincideLength(</span><br><span class="line">        value0,</span><br><span class="line">        value1,</span><br><span class="line">        value2,</span><br><span class="line">        r0,</span><br><span class="line">        r1,</span><br><span class="line">        coincideLengthAnchor,</span><br><span class="line">        coincideLengthAnchorMin,</span><br><span class="line">        coincideLengthAnchorMax</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这篇文章，并没有多么高深的技术。就是想分享一下，在遇到一个问题的探究过程中，碰到的有趣的经历与总结的一些经验。 这些经历与经验如果能给读者在以后的工作中贡献绵薄，我也就十分欣慰了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>维恩图（venn），也叫文氏图，用于显示元素集合重叠区域的图示。我们准备在echarts中提供这类图表。第一期支持两个集合的韦恩图，后期准备支持三个集合乃至多个集合的韦恩图</p>
<h3 id="准备">准备</h3>
<p>使用zrender框架，画出两个circle使之重叠，即可产生一个韦恩图。但是，互相重叠的部分会相互遮挡，（如下图）解决方案是对每个circle都调整透明度至50%。</p>
<div class="figure">
<img src="/blog/venn/img/opacity.png" alt="venn 透明度" /><p class="caption">venn 透明度</p>
</div>]]>
    
    </summary>
    
      <category term="ECharts" scheme="http://efe.baidu.com/tags/ECharts/"/>
    
      <category term="venn" scheme="http://efe.baidu.com/tags/venn/"/>
    
      <category term="数据可视化" scheme="http://efe.baidu.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[可伸缩的同构Javascript代码]]></title>
    <link href="http://efe.baidu.com/blog/isomorphic/"/>
    <id>http://efe.baidu.com/blog/isomorphic/</id>
    <published>2015-01-13T16:00:00.000Z</published>
    <updated>2015-01-14T02:30:28.000Z</updated>
    <content type="html"><![CDATA[<p>原文：<a href="http://blog.nodejitsu.com/scaling-isomorphic-javascript-code/" class="uri" target="_blank" rel="external">http://blog.nodejitsu.com/scaling-isomorphic-javascript-code/</a></p>
<p>译者注：这是一篇2011年的老文了，最近苦恼于单页面应用的首屏速度与SEO问题，期望本文能给有同样烦恼的同学们带来些启示。</p>
<p>先花点时间想想你是有多么频繁地听到“Model-View-Controller”（MVC）这词儿，但你真正明白它的意义吗？在较高层次上而言，它是指在一个基于图像系统（非光栅化图像，比如游戏）以展示为主的应用中对功能的<a href="http://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="external">关注点分离（separation of concerns）</a>。进一步看，它就是一堆表示不同事物的专有名词。过去，许多开发者社区都创造了各自的MVC解决方案，它们都能很好地应对流行的案例，并且在一步一步地发展。最好的例子就是Ruby和Python社区以及它们基于MVC架构的Rails与Django框架。</p>
<p>MVC模式已经被其它语言所接受，比如Java，Ruby和Python。但是对于Node.js而言还不够好，其中的一个原因就是：<strong>Javascript现在是一个同构的语言了</strong>。<strong>同构</strong>的意义就在于任何一段代码（当然有些特殊代码例外）都能同时跑在客户端与服务器端。从表面上讲，这个看似无害的特性带来了一系列当前的MVC模式无法解决的挑战。在这篇文章中我们会探寻目前存在一些的模式，看看它们都是怎样实现的，同时关注不同的语言及环境。另外也谈谈它们为什么对于真正同构的Javascript而言还不够好。在最后，我们会了解一种全新的模式：<a href="#resource-view-presenter%E4%BB%8B%E7%BB%8D">Resource-View-Presenter</a>。</p>
<a id="more"></a>
<h2 id="题要">题要</h2>
<p>设计模式在应用开发中至关重要。它们概述、封装了应用程序及其环境中值得关注的地方。在浏览器与服务器之间这些关注点差异很大：</p>
<ul>
<li>视图是短暂的（如在服务器上）还是长期存在的（如在浏览器上）？</li>
<li>视图是否能跨案例或场景复用？</li>
<li>视图是否该被应用特定的标签标记？</li>
<li>一堆堆的业务逻辑应该放哪里？（在Model中还是在Controller中？）</li>
<li>应用的状态应该如何持久化和访问？</li>
</ul>
<p>让我们来关注下目前存在的一些模式，看看它们是如何回答上面这些问题的：</p>
<ul>
<li><a href="#mvc">Model-View-Controller</a></li>
<li><a href="#model2">Model2</a></li>
<li><a href="#mvp--mvvm">Model-View Presenter and Model-View-ViewModel</a></li>
<li><a href="#%E7%8E%B0%E4%BB%A3%E5%8C%96%E7%9A%84javascript%E5%AE%9E%E7%8E%B0">现代化的Javascript实现</a></li>
<li><a href="#Resource-View-Presenter%E4%BB%8B%E7%BB%8D">Resource-View-Presenter介绍</a></li>
<li><a href="#%E7%BB%93%E8%AF%AD">结语</a></li>
</ul>
<h2 id="mvc">MVC</h2>
<div class="figure">
<img src="img/mvc.png" alt="Model-View-Controller"><p class="caption">Model-View-Controller</p>
</div>
<p>传统的Model-View-Controller模式（译注：为了与后续的Presenter, ViewModel保持一致，Model, View, Controller都不做翻译）假定View是持续的，同时，Controller是可热插拔的。比如说一个View对于是否登陆会对应不同的Controller。在一个较高的层次上而言，MVC并不关注View是如何被渲染（如具体是采用何种模版引擎）。</p>
<p>通过View是持续的及View定义用户交互来看，传统的MVC是对前端开发十分有利的模式。稍后我们会看到现实中，<a href="http://backbonejs.org/" target="_blank" rel="external">Backbone.js</a>实现的一个稍微改动的MVC模式。</p>
<h2 id="model2">Model2</h2>
<div class="figure">
<img src="img/model2.png" alt="Model2 Model-View-Controller"><p class="caption">Model2 Model-View-Controller</p>
</div>
<p>如果之前从来没有听过<a href="http://en.wikipedia.org/wiki/Model_2" target="_blank" rel="external">Model2</a>，请不要惊慌。它是一个可以追溯到1999年的设计模式，由Govind Seshadri提出并发表在<a href="http://www.javaworld.com/article/2076557/java-web-development/understanding-javaserver-pages-model-2-architecture.html" target="_blank" rel="external">Understanding JavaServer Pages Model 2 architecture</a>。可以说，Model2并不需要完全实现MVC模式，但现代大多数的实现（比如<a href="http://andrzejonsoftware.blogspot.com/2011/09/rails-is-not-mvc.html" target="_blank" rel="external">Ruby on Rails</a>）都以那种方式来设计。</p>
<p>在像Ruby on Rails的那些类Model2的框架中有一个共识：“富Model、瘦Controllers”。这不适用于所有的应用，但在作者看来，在实践中这一思路应用得还是相当广泛的。由于传统MVC中的Controller需要监听View并对输入作出反应，Controller会趋于繁重（比如越来越多的业务逻辑），因此“富Model、瘦Controller”的方式看上去更优。</p>
<p>鉴于无状态的HTTP，Model2的View是很短暂的：不同请求之间，View不保持状态。在大多数服务器端框架中，应用的状态都是通过<a href="http://en.wikipedia.org/wiki/HTTP_cookie" target="_blank" rel="external">Session Cookies</a>存储的。这使得Controller与View之间的单向通信非常有序，但这却不便于前端的开发。</p>
<h2 id="mvp-mvvm">MVP &amp; MVVM</h2>
<p>MVP(Model-View-Presenter)和MVVM(Model-View-ViewModel)模式与传统的MVC十分类似，除了以下几个关键区别：</p>
<ul>
<li>View不再直接持有对Model的引用</li>
<li>Presenter(或ViewModel)持有对View的引用并借助Model的改变来更新View</li>
</ul>
<p>MVP模式被Martin Fowler多次论述（<a href="http://www.martinfowler.com/eaaDev/uiArchs.html" target="_blank" rel="external">这儿</a>还有<a href="http://martinfowler.com/eaaDev/ModelViewPresenter.html" target="_blank" rel="external">这儿</a>），并且经常基于以下两个不同的实现来讨论：</p>
<ul>
<li><a href="http://www.martinfowler.com/eaaDev/PassiveScreen.html" target="_blank" rel="external">被动的View（Passive View）</a>：设计尽可能简单的View，除了必要的界面操作，其它所有的业务逻辑都应该包含在Presenter中</li>
<li><a href="http://www.martinfowler.com/eaaDev/SupervisingPresenter.html" target="_blank" rel="external">监督Controller（Supervising Controller）</a>：View可以包含简单的逻辑，Presenter只处理那些View无法处理的系统需求</li>
</ul>
<div class="figure">
<img src="img/mvp.png" alt="Model-View-Presenter"><p class="caption">Model-View-Presenter</p>
</div>
<div class="figure">
<img src="img/mvvm.png" alt="Model-View-ViewModel"><p class="caption">Model-View-ViewModel</p>
</div>
<p>MVP与MVVM几乎难以区分，除了一点：MVVM假定ViewModel中的改变会通过一个稳健的数据绑定引擎反映到View中。Niraj Bhatt在他的《<a href="http://nirajrules.wordpress.com/2009/07/18/mvc-vs-mvp-vs-mvvm/" target="_blank" rel="external">MVC vs. MVP vs. MVVM</a>》一文中指出：“如果在MVP中View有一个叫isChecked的属性并且由Presenter来设置的话，那么在MVVM中ViewModel也会有一个叫isChecked的属性并且与View保持同步。”</p>
<p>MVP与MVVM的优势是Presenter（或ViewModel）更容易进行单元测试。这是因为View的状态是由Presenter通过方法调用（MVP）或者由ViewModel通过属性设置（MVVM）来确定的。</p>
<p>对前端开发而言这两个模式都是可接受的好选择。在浏览器中，路由层可以将控制权交由适当的Presenter（或ViewModel），后者又可以更新并响应持续的View。通过一些小修改这两个模式都可以很好的运行在服务器端，其中的原因就在于Model与View之前没有直接的联系，这允许短暂View经由给定的Presenter（或ViewModel）进行渲染。就像稍后会描述的那样，这种改变后的模式就是真正意义上的同构。</p>
<h2 id="现代化的javascript实现">现代化的Javascript实现</h2>
<p>上面介绍的那些模式目前已经有许多现代化的实现：</p>
<ul>
<li><a href="http://backbonejs.org/" target="_blank" rel="external">Backbone.js</a></li>
<li><a href="http://batmanjs.org/" target="_blank" rel="external">Batman.js</a></li>
<li><a href="http://angularjs.org/" target="_blank" rel="external">Angularjs</a></li>
<li><a href="http://www.javascriptmvc.com/" target="_blank" rel="external">Javascript MVC</a></li>
<li><a href="http://sammyjs.org/" target="_blank" rel="external">Sammy</a></li>
</ul>
<p>这些框架通常都用于构建单页面应用（SPA, Singele-Page Application）。单页面应用的用户交互有两个截然不同的特点</p>
<ul>
<li>onHashChange 和 pushState 事件：当浏览器的URL改变时触发，比如导航到某某页面</li>
<li>DOM 事件：当用户在DOM上进行特定交互时触发，比如点击锚点标签</li>
</ul>
<p>让我们来瞅瞅具体的框架，如果你对此感兴趣的话可以参考下Peter Michaux关于<a href="http://michaux.ca/articles/mvc-architecture-for-javascript-applications" target="_blank" rel="external">JavascriptMVC框架开发</a>的文章。</p>
<h3 id="backbone">Backbone</h3>
<p><a href="http://backbonejs.org/" target="_blank" rel="external">Backbone.js</a>是当今最流行的客户端开发框架之一。它的核心是一个传统MVC模式的实现。但就像之前提到的，深入了解后就会发现这货与传统MVC有些出入。</p>
<div class="figure">
<img src="img/backbone.png" alt="Backbone Model-View-Controller"><p class="caption">Backbone Model-View-Controller</p>
</div>
<p>在上图中我们通过hashchange事件与DOM事件来分离控制流，以此来区分Backbone提供的入口点。通过区分这个细微差别充分说明了Backbone与传统MVC的一个重要的区别：<strong>视图可以操作数据</strong>。当我们查看<a href="http://backbonejs.org/docs/todos.html" target="_blank" rel="external">Backbone的TODO示例</a>时就能更清楚地认识到这点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.AppView = Backbone.View.extend(&#123;  </span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 通过一个Todo Model实例的参数来实例化View</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  addOne: <span class="function"><span class="keyword">function</span><span class="params">(todo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> view = <span class="keyword">new</span> TodoView(&#123;model: todo&#125;);</span><br><span class="line">    <span class="keyword">this</span>.$(<span class="string">"#todo-list"</span>).append(view.render().el);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.TodoView = Backbone.View.extend(&#123;  </span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 视图直接更新了Model的状态</span></span><br><span class="line">  <span class="comment">// 这有别于传统MVC中视图只监听数据变化的观点</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  toggleDone: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.model.toggle();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个有别于传统MVC模式的改变让大多数的Backone应用都有相似的感觉：简单的Controller、Model都被合并到庞大的View中。客观地来看，那些业务逻辑繁重的View本质上是Presenter。在大多数Backbone的项目代码库中你都能见到，在jQuery或Zepto等DOM框架的帮助下，大量的View被揉合在了一起。</p>
<p>对传统MVC模式的改变并没有错。在前端开发中，View持有对Model的引用能消除应用程序中大量的记账式逻辑。然而不管怎样，这个模式是不同构的。</p>
<h3 id="batman">Batman</h3>
<p><a href="http://batmanjs.org/" target="_blank" rel="external">Batman.js</a>是在<a href="http://2011.jsconf.us/#/proposal/6f23fd600302403a9f53e11390186b11" target="_blank" rel="external">2011年的JSConf</a>上发布的一个全新的Javascript框架（译注：这货已经不维护啦…就全当看看思路吧）。虽然Batman中的实体是Model、View与Controller，但其强大的数据绑定引擎与纯粹的HTML视图都暗示着这货实际是Model-View-ViewModel模式的实现。</p>
<div class="figure">
<img src="img/batman.png" alt="Batman Model-View-ViewModel"><p class="caption">Batman Model-View-ViewModel</p>
</div>
<p>没有大量使用Batman开发时很难有自信说大多数的Batman项目代码库都长什么样。但有种说法是：在应用中强调数据绑定引擎和瘦View预示着业务逻辑最终会在Controller与Model之间转播。</p>
<p>与Backone一样，Batman也改造了传统的Model-View-ViewModel模式：Model能直接与View通信并且ViewModel（如Controller）不再直接操作View。另外，由于Model与View之间存在引用，这模式不能轻易的作为一个服务器端模式来重用。但经过小小的改动就能变成服务器端的模式，如在Model层做一个适配使之能渲染一个静态的View来响应实时的请求。</p>
<h3 id="实时的含义">实时的含义</h3>
<p>在众多开发者关注的话题中“<strong>实时Web应用（realtime web applications）</strong>”一直名列前茅。那么以上讨论的那些模式对实时的支持又是如何的呢（比如<a href="http://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="external">WebSockets</a>）？</p>
<ul>
<li>Model-View-Controller (支持)：Model提供实时的事件监听并且能适当地更新View</li>
<li>Model2（不支持）：该模式使用了短暂View的概念，这意味着Controller不会监听来自Model的事件（译注：即使监听了也没用，View无状态、不保存）</li>
<li>Model-View-Presenter（支持）：Model提供实时的事件监听，会将事件派发给Presenter进而以适当的方式更新View</li>
<li>Model-View-ViewModel（支持）：Model提供实时的事件监听，会将事件派发给ViewModel进而以适当的方式更新View</li>
</ul>
<p>MVC、MVP、MVVM的这些特性使得<a href="http://backbonejs.org/" target="_blank" rel="external">Backbone.js</a>和<a href="http://batmanjs.org/" target="_blank" rel="external">Batman.js</a>对前端开发而言是实时框架。但在服务器端就不是这么一回事儿了：传统的MVC、MVP和MVVM模式由于View与Model之间紧密的联系阻碍了其与静态View的协作。</p>
<h2 id="resource-view-presenter介绍">Resource-View-Presenter介绍</h2>
<p>如上所述：MVC、MVP、MVVM模式都不能同时工作在客户端与服务器端。Resource-View-Presenter模式的关键之处就在于意识到了没有任何模式可以不经修改、完美地同时运行在客户端与服务器端。如之前介绍MVP与MVVP时提到的，通过对Model和View层去耦合，这两个模式可以真正地做到同构。</p>
<p>Resource-View-Presenter主要地思路是：</p>
<ul>
<li>View与Model去耦合</li>
<li>识别客户端与服务器端的区别并为之进行规划</li>
<li>期待瘦View、富Presenter和Resource</li>
<li>更倾向于将业务逻辑放在Resource中而非Presenter</li>
<li>允许短暂View（如服务器端地静态视图）与持续View（如客户端的DOM）同时存在</li>
<li>更倾向于使用Presenter而非ViewModel来保持标记语言（如HTML）的纯粹性</li>
<li>假设Presenter与Model是持续的</li>
</ul>
<p>虽然这些点看上去显得比较随意，但每一个都有特殊的目的：</p>
<ul>
<li>通过View与Model的去耦合，我们可以允许短暂View与持续View的并存</li>
<li>瘦View能与更现代化、更逻辑无关的模版引擎（比如<a href="https://github.com/hij1nx/weld" target="_blank" rel="external">weld</a>和<a href="http://mustache.github.com/" target="_blank" rel="external">mustache</a>）保持一致</li>
<li>使用Presenter替代ViewModel，使之能与对设计师友好的模版引擎（比如<a href="https://github.com/hij1nx/weld" target="_blank" rel="external">weld</a>）保持一致</li>
<li>假设Presenter与Model在客户端与服务器端都是持续的，这能使两端中的实时功能都被封装在Presenter中</li>
</ul>
<p>进一步看，RVP在客户端与传统的MVP模式类似。将Model改名为Resource主要是受“更倾向于将业务逻辑放在Resource中而非Presenter”这一个思路的影响。这也使得Resource在RVP中更像Model2模式中的重型Model，而非传统MVP模式中的Model。在应用RVP时，对于哪些逻辑应该属于Presenter有两点建议：<strong>那些对“瘦”View而言太繁重的展现逻辑，以及那些需要使用全局应用状态的业务逻辑</strong>。</p>
<p>就像<a href="http://backbonejs.org/" target="_blank" rel="external">Backbone.js</a>和<a href="http://batmanjs.org/" target="_blank" rel="external">Batman.js</a>，客户端的RVP实现应该同时支持OnHashChange/pushState事件与DOM事件。</p>
<div class="figure">
<img src="img/client_rvp.png" alt="客户端Resource-View-Presenter"><p class="caption">客户端Resource-View-Presenter</p>
</div>
<p>在服务器端的Resource-View-Presenter与客户端上的几乎完全相同，除了一个明显的例外：View是短暂，不会向Presenter传递调用也不会持有对Presenter的引用。实际上，当基于JSON的Web服务器上使用RVP架构时，View几乎都没有存在的必要，仅仅只需要调用下<code>JSON.stringify()</code>就好啦。</p>
<div class="figure">
<img src="img/server_rvp.png" alt="服务器端Resource-View-Presenter"><p class="caption">服务器端Resource-View-Presenter</p>
</div>
<p>初步看来，服务器端的RVP和<a href="#model2">Model2</a>很像，区别在于持续的Presenter和Model都能支持实时事件，这就使得这种相似性显得比较肤浅了。Model是由实时数据源（比如<a href="http://redis.io/topics/pubsub" target="_blank" rel="external">Redis PubSub</a>和<a href="http://guide.couchdb.org/draft/notifications.html" target="_blank" rel="external">CouchDB changes</a>）支持的，RVP通过监听Model的事件与改变来实现对实时事件的支持。</p>
<p>需要特别关注的是对实时的支持，因为它可以让应用开发者聚焦于业务逻辑的开发而非底层的网络传输。这听上去似乎无关紧要，但是如果仔细观察<a href="http://expressjs.org/" target="_blank" rel="external">Express</a>和<a href="http://socket.io/" target="_blank" rel="external">Socket.io</a>提供的模式就能看出明显的差异：</p>
<div class="figure">
<img src="img/express.png" alt="Express和Socket.io"><p class="caption">Express和Socket.io</p>
</div>
<p>这并非是指<a href="http://expressjs.org/" target="_blank" rel="external">Express</a>和<a href="http://socket.io/" target="_blank" rel="external">Socket.io</a>不优秀，而是在说：它们都很明确自己提供的是什么而且做得相当好。在更高层次的设计模式中，这都不是事儿。</p>
<h2 id="结语">结语</h2>
<p>编写大型应用难，在服务器与客户端之间封装、重用组件就更难了。通过这些分析，期望能让RVP模式在具体项目中如何实施更清晰，从而使之更容易在服务器与客户端之间复用组件。</p>
<p>没有时间去自己实现？没问题！这篇文章就是来源自<a href="https://github.com/nodejitsu" target="_blank" rel="external">大量开源项目</a>，在开发者深思熟虑、辛苦工作后产生的结晶。我们的观念始终如一：创建最好的工具来引领最好的系统。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文：<a href="http://blog.nodejitsu.com/scaling-isomorphic-javascript-code/" class="uri">http://blog.nodejitsu.com/scaling-isomorphic-javascript-code/</a></p>
<p>译者注：这是一篇2011年的老文了，最近苦恼于单页面应用的首屏速度与SEO问题，期望本文能给有同样烦恼的同学们带来些启示。</p>
<p>先花点时间想想你是有多么频繁地听到“Model-View-Controller”（MVC）这词儿，但你真正明白它的意义吗？在较高层次上而言，它是指在一个基于图像系统（非光栅化图像，比如游戏）以展示为主的应用中对功能的<a href="http://en.wikipedia.org/wiki/Separation_of_concerns">关注点分离（separation of concerns）</a>。进一步看，它就是一堆表示不同事物的专有名词。过去，许多开发者社区都创造了各自的MVC解决方案，它们都能很好地应对流行的案例，并且在一步一步地发展。最好的例子就是Ruby和Python社区以及它们基于MVC架构的Rails与Django框架。</p>
<p>MVC模式已经被其它语言所接受，比如Java，Ruby和Python。但是对于Node.js而言还不够好，其中的一个原因就是：<strong>Javascript现在是一个同构的语言了</strong>。<strong>同构</strong>的意义就在于任何一段代码（当然有些特殊代码例外）都能同时跑在客户端与服务器端。从表面上讲，这个看似无害的特性带来了一系列当前的MVC模式无法解决的挑战。在这篇文章中我们会探寻目前存在一些的模式，看看它们都是怎样实现的，同时关注不同的语言及环境。另外也谈谈它们为什么对于真正同构的Javascript而言还不够好。在最后，我们会了解一种全新的模式：<a href="#resource-view-presenter%E4%BB%8B%E7%BB%8D">Resource-View-Presenter</a>。</p>]]>
    
    </summary>
    
      <category term="Isomorphic" scheme="http://efe.baidu.com/tags/Isomorphic/"/>
    
      <category term="JavaScript" scheme="http://efe.baidu.com/tags/JavaScript/"/>
    
      <category term="NodeJS" scheme="http://efe.baidu.com/tags/NodeJS/"/>
    
  </entry>
  
</feed>